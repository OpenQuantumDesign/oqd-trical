<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>trical.classes.potential API documentation</title>
<meta name="description" content="Defines the Potential class and its subclasses representing potentials associated with
a trapped ions system" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>trical.classes.potential</code></h1>
</header>
<section id="section-intro">
<p>Defines the Potential class and its subclasses representing potentials associated with
a trapped ions system</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines the Potential class and its subclasses representing potentials associated with
a trapped ions system
&#34;&#34;&#34;
from .. import constants as cst
from ..misc.linalg import norm
from ..misc.setalg import intersection
import itertools as itr
import numpy as np
from numpy.polynomial import polynomial as poly
import sympy


class Potential(object):

    &#34;&#34;&#34;
    Object representing a general potential

    Attributes:
        d2phi (func(str,str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that
        takes two strings representing the derivative variables and outputs the function
        corresponding to the derivative of the potential with respect to the derivative
        variables
        dphi (func(str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that
        takes a string representing the derivative variable and outputs the function
        corresponding to the derivative of the potential with respect to the derivative
        variable
        phi (func(1-D or 2-D array of float)): Function representing the potential
        params (dict): Other relevant parameters of the Potential object
    &#34;&#34;&#34;

    def __init__(self, phi, dphi, d2phi, **kwargs):
        &#34;&#34;&#34;
        Initialization function for a Potential object

        Args:
            phi (func(1-D or 2-D array of float)): Function representing the potential
            dphi (func(str,str) -&gt; (func(1-D or 2-D array of float) -&gt; float)):
            Function that takes a string representing the derivative variable and outputs
            the function corresponding to the derivative of the potential with respect to
            the derivative variable
            d2phi (func(str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that
            takes two strings representing the derivative variables and outputs the function
            corresponding to the derivative of the potential with respect to the
            derivative variables

        Kwargs:
            dim (int, optional): Dimension of the system
            m (float, optional): Mass of an ion
            N (int, optional): Number of Ions
            q (float, optional): Charge of an ion

        &#34;&#34;&#34;
        super(Potential, self).__init__()

        self.phi = phi
        self.dphi = dphi
        self.d2phi = d2phi

        params = {&#34;dim&#34;: 3}
        params.update(kwargs)
        self.__dict__.update(params)
        self.params = params
        pass

    def __add__(self, other):
        &#34;&#34;&#34;
        Adds two Potential objects

        Args:
            other (Potential): Potential object of interest

        Returns:
            Potential: Addition of the potentials
        &#34;&#34;&#34;
        for i in intersection(self.params.keys(), other.params.keys()):
            assert self.params[i] == other.params[i]

        params = {}
        params.update(self.params)
        params.update(other.params)
        phi = lambda x: self.phi(x) + other.phi(x)
        dphi = lambda var: (lambda x: self.dphi(var)(x) + other.dphi(var)(x))
        d2phi = lambda var1, var2: (
            lambda x: self.d2phi(var1, var2)(x) + other.d2phi(var1, var2)(x)
        )
        return Potential(phi, dphi, d2phi, **params)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Subtracts two Potential objects

        Args:
            other (Potential): Potential object of interest

        Returns:
            Potential: Subtraction of the potentials
        &#34;&#34;&#34;
        for i in intersection(self.params.keys(), other.params.keys()):
            assert self.params[i] == other.params[i]

        params = {}
        params.update(self.params)
        params.update(other.params)
        phi = lambda x: self.phi(x) - other.phi(x)
        dphi = lambda var: (lambda x: self.dphi(var)(x) - other.dphi(var)(x))
        d2phi = lambda var1, var2: (
            lambda x: self.d2phi(var1, var2)(x) - other.d2phi(var1, var2)(x)
        )
        return Potential(phi, dphi, d2phi, **params)

    def __mul__(self, multiplier):
        &#34;&#34;&#34;
        Multiplies Potential objects by some multiplier

        Args:
            multiplier (float): Scalar to multiply the potential by

        Returns:
            Potential: The potential multiplied by the multiplier
        &#34;&#34;&#34;
        phi = lambda x: self.phi(x) * multiplier
        dphi = lambda var: (lambda x: self.dphi(var)(x) * multiplier)
        d2phi = lambda var1, var2: (lambda x: self.d2phi(var1, var2)(x) * multiplier)
        return Potential(phi, dphi, d2phi, **self.params)

    def __rmul__(self, multiplier):
        &#34;&#34;&#34;
        Multiplies Potential objects by some multiplier

        Args:
            multiplier (float): Scalar to multiply the potential by

        Returns:
            Potential: The potential multiplied by the multiplier
        &#34;&#34;&#34;
        return self * multiplier

    def __truediv__(self, divisor):
        &#34;&#34;&#34;
        Divides Potential objects by some divisor

        Args:
            divisor (float): Scalar to divide the potential by

        Returns:
            Potential: The potential divided by the divisor
        &#34;&#34;&#34;
        phi = lambda x: self.phi(x) / divisor
        dphi = lambda var: (lambda x: self.dphi(var)(x) / divisor)
        d2phi = lambda var1, var2: (lambda x: self.d2phi(var1, var2)(x) / divisor)
        return Potential(phi, dphi, d2phi, **self.params)

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the potential given the position of the ions
        &#34;&#34;&#34;
        return self.phi(x)

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the potential with respect to a variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the potential with respect to the derivative variable
        &#34;&#34;&#34;
        return self.dphi(var)

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the potential with respect to two variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the potential with respect to the derivative variables
        &#34;&#34;&#34;
        return self.d2phi(var1, var2)

    def gradient(self):
        &#34;&#34;&#34;
        Calculates the gradient of the potential

        Returns:
            func(1-D or 2-D array of float) -&gt; 1-D array of float: Function corresponding
            to the gradient of the potential
        &#34;&#34;&#34;

        def grad_phi(x):
            &#34;&#34;&#34;
            Function corresponding to the gradient of the potential

            Args:
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                1-D array of float: Value of the gradient of the potential given the
                position of the ions
            &#34;&#34;&#34;
            grad_phi_x = np.empty(self.N * self.dim)

            i = 0
            for var in itr.product(
                [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
            ):
                grad_phi_x[i] = self.dphi(var)(x)
                i += 1
            return grad_phi_x

        return grad_phi

    def hessian(self):
        &#34;&#34;&#34;
        Calculates the Hessian of the potential

        Returns:
            func(1-D or 2-D array of float) -&gt; 2-D array of float: Function corresponding
            to the Hessian of the potential
        &#34;&#34;&#34;

        def hess_phi(x):
            &#34;&#34;&#34;
            Function corresponding to the Hessian of the potential

            Args:s
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                1-D array of float: Value of the Hessian of the potential given the
                position of the ions
            &#34;&#34;&#34;
            hess_phi_x = np.empty((self.N * self.dim, self.N * self.dim))

            i = 0
            for var1 in itr.product(
                [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
            ):
                j = 0
                for var2 in itr.product(
                    [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
                ):
                    hess_phi_x[i, j] = self.d2phi(var1, var2)(x)
                    j += 1
                i += 1
            return hess_phi_x

        return hess_phi

    def update_params(self, **kwargs):
        &#34;&#34;&#34;
        Updates parameters of Potential object

        Kwargs:
            dim (int, optional): Dimension of the system
            m (float, optional): Mass of an ion
            N (int, optional): Number of Ions
            q (float, optional): Charge of an ion

        &#34;&#34;&#34;
        self.params.update(kwargs)
        self.__dict__.update(self.params)
        pass

    pass


class CoulombPotential(Potential):

    &#34;&#34;&#34;
    Object representing a Coulomb potential
    &#34;&#34;&#34;

    def __init__(self, N, **kwargs):
        &#34;&#34;&#34;
        Initialization function for a CoulombPotential object

        Args:
            N (int): Number of ions

        Kwargs:
            N (int): Number of Ions
            dim (int, optional): Dimension of the system
            q (float, optional): Charge of an ion
        &#34;&#34;&#34;
        params = {&#34;dim&#34;: 3, &#34;N&#34;: N, &#34;q&#34;: cst.e}
        params.update(kwargs)

        super(CoulombPotential, self).__init__(
            self.__call__, self.first_derivative, self.second_derivative, **params
        )
        pass

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the Coulomb potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the Coulomb potential given the position of the ions
        &#34;&#34;&#34;
        i, j = (
            np.fromiter(itr.chain(*itr.combinations(range(self.N), 2)), dtype=int)
            .reshape(-1, 2)
            .transpose()
        )
        nxij = norm(x[i] - x[j])
        return cst.k * self.q ** 2 * (1 / nxij).sum()

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the Coulomb potential with respect to a variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the Coulomb potential with respect to the derivative
            variable
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
        i = int(var[1:] if type(var) == str else var[1:][0]) - 1
        j = np.delete(np.arange(self.N, dtype=int), i)

        def dphi_dai(x):
            &#34;&#34;&#34;
            Function corresponding to a first derivative of the Coulomb potential

            Args:
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                float: Value of a first derivative of the Coulomb potential given the
                position of the ions
            &#34;&#34;&#34;
            xia = x[i, a]
            xja = x[j, a]
            nxij = norm(x[i] - x[j])
            return cst.k * self.q ** 2 * ((xja - xia) / nxij ** 3).sum()

        return dphi_dai

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the Coulomb potential with respect to two
        variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the Coulomb potential with respect to the derivative
            variables
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
        b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
        i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
        j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

        def d2phi_daidbj(x):
            &#34;&#34;&#34;
            Function corresponding to a second derivative of the Coulomb potential

            Args:s
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                float: Value of a second derivative of the Coulomb potential given the
                position of the ions
            &#34;&#34;&#34;
            if i == j:
                k = np.delete(np.arange(self.N, dtype=int), i)
                xia = x[i, a]
                xka = x[k, a]
                xib = x[i, b]
                xkb = x[k, b]
                nxik = norm(x[i] - x[k])
                if a == b:
                    return (
                        cst.k
                        * self.q ** 2
                        * ((-1 / nxik ** 3 + 3 * (xka - xia) ** 2 / nxik ** 5)).sum()
                    )
                else:
                    return (
                        cst.k
                        * self.q ** 2
                        * (3 * (xka - xia) * (xkb - xib) / nxik ** 5).sum()
                    )
            else:
                xia = x[i, a]
                xja = x[j, a]
                xib = x[i, b]
                xjb = x[j, b]
                nxij = norm(x[i] - x[j])
                if a == b:
                    return (
                        cst.k
                        * self.q ** 2
                        * (1 / nxij ** 3 - 3 * (xja - xia) ** 2 / nxij ** 5)
                    )
                else:
                    return (
                        cst.k
                        * self.q ** 2
                        * (-3 * (xja - xia) * (xjb - xib) / nxij ** 5)
                    )

        return d2phi_daidbj

    def nondimensionalize(self, l):
        &#34;&#34;&#34;
        Nondimensionalizes the Coulomb potential using a length scale

        Args:
            l (float): A length scale

        Returns:
            Potential: Nondimensionalized Coulomb potential
        &#34;&#34;&#34;
        return self / (cst.k * cst.e ** 2)

    pass


class PolynomialPotential(Potential):

    &#34;&#34;&#34;
    Object representing a Polynomial potential

    Attributes:
        alpha (1-D, 2-D or 3-D array of float): Polynomial coefficients
        deg (int or 1-D array of int): Degree of Polynomial
        dim (int, optional): Dimension of the system
    &#34;&#34;&#34;

    def __init__(self, alpha):
        &#34;&#34;&#34;
        Initialization function for a PolynomialPotential object

        Args:
            alpha (1-D, 2-D or 3-D array of float): Polynomial coefficients
        &#34;&#34;&#34;
        self.alpha = np.array(alpha)
        self.deg = np.array(alpha.shape) - 1

        params = {&#34;dim&#34;: len(alpha.shape)}

        super(PolynomialPotential, self).__init__(
            self.__call__, self.first_derivative, self.second_derivative, **params
        )
        pass

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the polynomial potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the polynomial potential given the position of the ions
        &#34;&#34;&#34;
        return {1: poly.polyval, 2: poly.polyval2d, 3: poly.polyval3d}[self.dim](
            *x.transpose(), self.alpha
        ).sum()

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the polynomial potential with respect to a variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the polynomial potential with respect to the derivative
            variable
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
        i = int(var[1:] if type(var) == str else var[1:][0]) - 1

        beta = poly.polyder(self.alpha, axis=a)

        dphi_dai = lambda x: {1: poly.polyval, 2: poly.polyval2d, 3: poly.polyval3d}[
            self.dim
        ](*x[i], beta)

        return dphi_dai

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the polynomial potential with respect to two
        variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the polynomial potential with respect to the derivative
            variables
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
        b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
        i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
        j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

        beta = poly.polyder(self.alpha, axis=a)
        gamma = poly.polyder(beta, axis=b)

        if i == j:
            d2phi_daidbj = lambda x: {
                1: poly.polyval,
                2: poly.polyval2d,
                3: poly.polyval3d,
            }[self.dim](*x[i], gamma)
        else:
            d2phi_daidbj = lambda x: 0.0

        return d2phi_daidbj

    def nondimensionalize(self, l):
        &#34;&#34;&#34;
        Nondimensionalizes the polynomial potential using a length scale

        Args:
            l (float): A length scale

        Returns:
            PolynomialPotential: Nondimensionalized polynomial potential
        &#34;&#34;&#34;
        alpha = (
            l ** np.indices(self.alpha.shape).sum(0)
            * self.alpha
            * (l / (cst.k * cst.e ** 2))
        )
        return PolynomialPotential(alpha)

    pass


class SymbolicPotential(Potential):

    &#34;&#34;&#34;
    Object representing a symbolically defined potential

    Attributes:
        expr (sympy): Symbolic expression of the potential
        dim (int, optional): Dimension of the system
    &#34;&#34;&#34;

    def __init__(self, expr, **kwargs):
        &#34;&#34;&#34;
        Initialization function for a SymbolicPotential object

        Args:
            expr (sympy): Symbolic expression of the potential
        Kwargs:
            dim (int, optional): Dimension of the system
        &#34;&#34;&#34;
        self.expr = expr

        params = {&#34;dim&#34;: 3}
        params.update(kwargs)
        self.__dict__.update(params)
        self.params = params

        self.symbol = [sympy.Symbol([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][i]) for i in range(self.dim)]
        self.lambdified_expr = sympy.utilities.lambdify(self.symbol, expr)

        super(SymbolicPotential, self).__init__(
            self.__call__, self.first_derivative, self.second_derivative, **params
        )
        pass

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the symbolically defined potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the symbolically defined potential given the position of the ions
        &#34;&#34;&#34;
        return self.lambdified_expr(*x.transpose()).sum()

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the symbolically defined potential with respect to a
        variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the symbolically defined potential with respect to the derivative
            variable
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
        i = int(var[1:] if type(var) == str else var[1:][0]) - 1

        dphi_dai = lambda x: sympy.utilities.lambdify(
            self.symbol, sympy.diff(self.expr, self.symbol[a])
        )(*x[i])

        return dphi_dai

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the symbolically defined potential with respect to two
        variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the symbolically defined potential with respect to the derivative
            variables
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
        b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
        i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
        j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

        if i == j:
            d2phi_daidbj = lambda x: sympy.utilities.lambdify(
                self.symbol, sympy.diff(self.expr, self.symbol[a], self.symbol[b])
            )(*x[i])
        else:
            d2phi_daidbj = lambda x: 0

        return d2phi_daidbj

    def nondimensionalize(self, l):
        &#34;&#34;&#34;
        Nondimensionalizes the symbolically defined potential using a length scale

        Args:
            l (float): A length scale

        Returns:
            PolynomialPotential: Nondimensionalized symbolically defined potential
        &#34;&#34;&#34;
        expr = self.expr.subs({k: k * l for k in self.symbol}) * (
            l / (cst.k * cst.e ** 2)
        )
        return SymbolicPotential(expr, **self.params)

    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="trical.classes.potential.CoulombPotential"><code class="flex name class">
<span>class <span class="ident">CoulombPotential</span></span>
<span>(</span><span>N, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Object representing a Coulomb potential</p>
<p>Initialization function for a CoulombPotential object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of ions</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of Ions</dd>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of the system</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Charge of an ion</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoulombPotential(Potential):

    &#34;&#34;&#34;
    Object representing a Coulomb potential
    &#34;&#34;&#34;

    def __init__(self, N, **kwargs):
        &#34;&#34;&#34;
        Initialization function for a CoulombPotential object

        Args:
            N (int): Number of ions

        Kwargs:
            N (int): Number of Ions
            dim (int, optional): Dimension of the system
            q (float, optional): Charge of an ion
        &#34;&#34;&#34;
        params = {&#34;dim&#34;: 3, &#34;N&#34;: N, &#34;q&#34;: cst.e}
        params.update(kwargs)

        super(CoulombPotential, self).__init__(
            self.__call__, self.first_derivative, self.second_derivative, **params
        )
        pass

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the Coulomb potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the Coulomb potential given the position of the ions
        &#34;&#34;&#34;
        i, j = (
            np.fromiter(itr.chain(*itr.combinations(range(self.N), 2)), dtype=int)
            .reshape(-1, 2)
            .transpose()
        )
        nxij = norm(x[i] - x[j])
        return cst.k * self.q ** 2 * (1 / nxij).sum()

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the Coulomb potential with respect to a variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the Coulomb potential with respect to the derivative
            variable
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
        i = int(var[1:] if type(var) == str else var[1:][0]) - 1
        j = np.delete(np.arange(self.N, dtype=int), i)

        def dphi_dai(x):
            &#34;&#34;&#34;
            Function corresponding to a first derivative of the Coulomb potential

            Args:
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                float: Value of a first derivative of the Coulomb potential given the
                position of the ions
            &#34;&#34;&#34;
            xia = x[i, a]
            xja = x[j, a]
            nxij = norm(x[i] - x[j])
            return cst.k * self.q ** 2 * ((xja - xia) / nxij ** 3).sum()

        return dphi_dai

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the Coulomb potential with respect to two
        variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the Coulomb potential with respect to the derivative
            variables
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
        b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
        i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
        j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

        def d2phi_daidbj(x):
            &#34;&#34;&#34;
            Function corresponding to a second derivative of the Coulomb potential

            Args:s
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                float: Value of a second derivative of the Coulomb potential given the
                position of the ions
            &#34;&#34;&#34;
            if i == j:
                k = np.delete(np.arange(self.N, dtype=int), i)
                xia = x[i, a]
                xka = x[k, a]
                xib = x[i, b]
                xkb = x[k, b]
                nxik = norm(x[i] - x[k])
                if a == b:
                    return (
                        cst.k
                        * self.q ** 2
                        * ((-1 / nxik ** 3 + 3 * (xka - xia) ** 2 / nxik ** 5)).sum()
                    )
                else:
                    return (
                        cst.k
                        * self.q ** 2
                        * (3 * (xka - xia) * (xkb - xib) / nxik ** 5).sum()
                    )
            else:
                xia = x[i, a]
                xja = x[j, a]
                xib = x[i, b]
                xjb = x[j, b]
                nxij = norm(x[i] - x[j])
                if a == b:
                    return (
                        cst.k
                        * self.q ** 2
                        * (1 / nxij ** 3 - 3 * (xja - xia) ** 2 / nxij ** 5)
                    )
                else:
                    return (
                        cst.k
                        * self.q ** 2
                        * (-3 * (xja - xia) * (xjb - xib) / nxij ** 5)
                    )

        return d2phi_daidbj

    def nondimensionalize(self, l):
        &#34;&#34;&#34;
        Nondimensionalizes the Coulomb potential using a length scale

        Args:
            l (float): A length scale

        Returns:
            Potential: Nondimensionalized Coulomb potential
        &#34;&#34;&#34;
        return self / (cst.k * cst.e ** 2)

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential">Potential</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="trical.classes.potential.CoulombPotential.first_derivative"><code class="name flex">
<span>def <span class="ident">first_derivative</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the first derivative of the Coulomb potential with respect to a variable</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code></dt>
<dd>Derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>first</code> <code>derivative</code> of <code>the</code> <code>Coulomb</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code></dt>
<dd>&nbsp;</dd>
<dt><code>variable</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_derivative(self, var):
    &#34;&#34;&#34;
    Calculates the first derivative of the Coulomb potential with respect to a variable

    Args:
        var (str): Derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        first derivative of the Coulomb potential with respect to the derivative
        variable
    &#34;&#34;&#34;
    a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
    i = int(var[1:] if type(var) == str else var[1:][0]) - 1
    j = np.delete(np.arange(self.N, dtype=int), i)

    def dphi_dai(x):
        &#34;&#34;&#34;
        Function corresponding to a first derivative of the Coulomb potential

        Args:
            x (1-D or 2-D array of float): Position of the ions

        Returns:
            float: Value of a first derivative of the Coulomb potential given the
            position of the ions
        &#34;&#34;&#34;
        xia = x[i, a]
        xja = x[j, a]
        nxij = norm(x[i] - x[j])
        return cst.k * self.q ** 2 * ((xja - xia) / nxij ** 3).sum()

    return dphi_dai</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.CoulombPotential.nondimensionalize"><code class="name flex">
<span>def <span class="ident">nondimensionalize</span></span>(<span>self, l)</span>
</code></dt>
<dd>
<section class="desc"><p>Nondimensionalizes the Coulomb potential using a length scale</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>A length scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential"><code>Potential</code></a></strong></dt>
<dd>Nondimensionalized Coulomb potential</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nondimensionalize(self, l):
    &#34;&#34;&#34;
    Nondimensionalizes the Coulomb potential using a length scale

    Args:
        l (float): A length scale

    Returns:
        Potential: Nondimensionalized Coulomb potential
    &#34;&#34;&#34;
    return self / (cst.k * cst.e ** 2)</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.CoulombPotential.second_derivative"><code class="name flex">
<span>def <span class="ident">second_derivative</span></span>(<span>self, var1, var2)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the second derivative of the Coulomb potential with respect to two
variables</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var1</code></strong> :&ensp;<code>str</code></dt>
<dd>first derivative variable</dd>
<dt><strong><code>var2</code></strong> :&ensp;<code>str</code></dt>
<dd>second derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>second</code> <code>derivative</code> of <code>the</code> <code>Coulomb</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code></dt>
<dd>&nbsp;</dd>
<dt><code>variables</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative(self, var1, var2):
    &#34;&#34;&#34;
    Calculates the second derivative of the Coulomb potential with respect to two
    variables

    Args:
        var1 (str): first derivative variable
        var2 (str): second derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        second derivative of the Coulomb potential with respect to the derivative
        variables
    &#34;&#34;&#34;
    a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
    b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
    i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
    j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

    def d2phi_daidbj(x):
        &#34;&#34;&#34;
        Function corresponding to a second derivative of the Coulomb potential

        Args:s
            x (1-D or 2-D array of float): Position of the ions

        Returns:
            float: Value of a second derivative of the Coulomb potential given the
            position of the ions
        &#34;&#34;&#34;
        if i == j:
            k = np.delete(np.arange(self.N, dtype=int), i)
            xia = x[i, a]
            xka = x[k, a]
            xib = x[i, b]
            xkb = x[k, b]
            nxik = norm(x[i] - x[k])
            if a == b:
                return (
                    cst.k
                    * self.q ** 2
                    * ((-1 / nxik ** 3 + 3 * (xka - xia) ** 2 / nxik ** 5)).sum()
                )
            else:
                return (
                    cst.k
                    * self.q ** 2
                    * (3 * (xka - xia) * (xkb - xib) / nxik ** 5).sum()
                )
        else:
            xia = x[i, a]
            xja = x[j, a]
            xib = x[i, b]
            xjb = x[j, b]
            nxij = norm(x[i] - x[j])
            if a == b:
                return (
                    cst.k
                    * self.q ** 2
                    * (1 / nxij ** 3 - 3 * (xja - xia) ** 2 / nxij ** 5)
                )
            else:
                return (
                    cst.k
                    * self.q ** 2
                    * (-3 * (xja - xia) * (xjb - xib) / nxij ** 5)
                )

    return d2phi_daidbj</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential">Potential</a></b></code>:
<ul class="hlist">
<li><code><a title="trical.classes.potential.Potential.gradient" href="#trical.classes.potential.Potential.gradient">gradient</a></code></li>
<li><code><a title="trical.classes.potential.Potential.hessian" href="#trical.classes.potential.Potential.hessian">hessian</a></code></li>
<li><code><a title="trical.classes.potential.Potential.update_params" href="#trical.classes.potential.Potential.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="trical.classes.potential.PolynomialPotential"><code class="flex name class">
<span>class <span class="ident">PolynomialPotential</span></span>
<span>(</span><span>alpha)</span>
</code></dt>
<dd>
<section class="desc"><p>Object representing a Polynomial potential</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>alpha (1-D, 2-D or 3-D array of float): Polynomial coefficients</dt>
<dt>deg (int or 1-D array of int): Degree of Polynomial</dt>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of the system</dd>
</dl>
<p>Initialization function for a PolynomialPotential object</p>
<h2 id="args">Args</h2>
<p>alpha (1-D, 2-D or 3-D array of float): Polynomial coefficients</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolynomialPotential(Potential):

    &#34;&#34;&#34;
    Object representing a Polynomial potential

    Attributes:
        alpha (1-D, 2-D or 3-D array of float): Polynomial coefficients
        deg (int or 1-D array of int): Degree of Polynomial
        dim (int, optional): Dimension of the system
    &#34;&#34;&#34;

    def __init__(self, alpha):
        &#34;&#34;&#34;
        Initialization function for a PolynomialPotential object

        Args:
            alpha (1-D, 2-D or 3-D array of float): Polynomial coefficients
        &#34;&#34;&#34;
        self.alpha = np.array(alpha)
        self.deg = np.array(alpha.shape) - 1

        params = {&#34;dim&#34;: len(alpha.shape)}

        super(PolynomialPotential, self).__init__(
            self.__call__, self.first_derivative, self.second_derivative, **params
        )
        pass

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the polynomial potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the polynomial potential given the position of the ions
        &#34;&#34;&#34;
        return {1: poly.polyval, 2: poly.polyval2d, 3: poly.polyval3d}[self.dim](
            *x.transpose(), self.alpha
        ).sum()

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the polynomial potential with respect to a variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the polynomial potential with respect to the derivative
            variable
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
        i = int(var[1:] if type(var) == str else var[1:][0]) - 1

        beta = poly.polyder(self.alpha, axis=a)

        dphi_dai = lambda x: {1: poly.polyval, 2: poly.polyval2d, 3: poly.polyval3d}[
            self.dim
        ](*x[i], beta)

        return dphi_dai

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the polynomial potential with respect to two
        variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the polynomial potential with respect to the derivative
            variables
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
        b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
        i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
        j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

        beta = poly.polyder(self.alpha, axis=a)
        gamma = poly.polyder(beta, axis=b)

        if i == j:
            d2phi_daidbj = lambda x: {
                1: poly.polyval,
                2: poly.polyval2d,
                3: poly.polyval3d,
            }[self.dim](*x[i], gamma)
        else:
            d2phi_daidbj = lambda x: 0.0

        return d2phi_daidbj

    def nondimensionalize(self, l):
        &#34;&#34;&#34;
        Nondimensionalizes the polynomial potential using a length scale

        Args:
            l (float): A length scale

        Returns:
            PolynomialPotential: Nondimensionalized polynomial potential
        &#34;&#34;&#34;
        alpha = (
            l ** np.indices(self.alpha.shape).sum(0)
            * self.alpha
            * (l / (cst.k * cst.e ** 2))
        )
        return PolynomialPotential(alpha)

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential">Potential</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="trical.classes.potential.PolynomialPotential.first_derivative"><code class="name flex">
<span>def <span class="ident">first_derivative</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the first derivative of the polynomial potential with respect to a variable</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code></dt>
<dd>Derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>first</code> <code>derivative</code> of <code>the</code> <code>polynomial</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code></dt>
<dd>&nbsp;</dd>
<dt><code>variable</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_derivative(self, var):
    &#34;&#34;&#34;
    Calculates the first derivative of the polynomial potential with respect to a variable

    Args:
        var (str): Derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        first derivative of the polynomial potential with respect to the derivative
        variable
    &#34;&#34;&#34;
    a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
    i = int(var[1:] if type(var) == str else var[1:][0]) - 1

    beta = poly.polyder(self.alpha, axis=a)

    dphi_dai = lambda x: {1: poly.polyval, 2: poly.polyval2d, 3: poly.polyval3d}[
        self.dim
    ](*x[i], beta)

    return dphi_dai</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.PolynomialPotential.nondimensionalize"><code class="name flex">
<span>def <span class="ident">nondimensionalize</span></span>(<span>self, l)</span>
</code></dt>
<dd>
<section class="desc"><p>Nondimensionalizes the polynomial potential using a length scale</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>A length scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="trical.classes.potential.PolynomialPotential" href="#trical.classes.potential.PolynomialPotential"><code>PolynomialPotential</code></a></strong></dt>
<dd>Nondimensionalized polynomial potential</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nondimensionalize(self, l):
    &#34;&#34;&#34;
    Nondimensionalizes the polynomial potential using a length scale

    Args:
        l (float): A length scale

    Returns:
        PolynomialPotential: Nondimensionalized polynomial potential
    &#34;&#34;&#34;
    alpha = (
        l ** np.indices(self.alpha.shape).sum(0)
        * self.alpha
        * (l / (cst.k * cst.e ** 2))
    )
    return PolynomialPotential(alpha)</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.PolynomialPotential.second_derivative"><code class="name flex">
<span>def <span class="ident">second_derivative</span></span>(<span>self, var1, var2)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the second derivative of the polynomial potential with respect to two
variables</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var1</code></strong> :&ensp;<code>str</code></dt>
<dd>first derivative variable</dd>
<dt><strong><code>var2</code></strong> :&ensp;<code>str</code></dt>
<dd>second derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>second</code> <code>derivative</code> of <code>the</code> <code>polynomial</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code></dt>
<dd>&nbsp;</dd>
<dt><code>variables</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative(self, var1, var2):
    &#34;&#34;&#34;
    Calculates the second derivative of the polynomial potential with respect to two
    variables

    Args:
        var1 (str): first derivative variable
        var2 (str): second derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        second derivative of the polynomial potential with respect to the derivative
        variables
    &#34;&#34;&#34;
    a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
    b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
    i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
    j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

    beta = poly.polyder(self.alpha, axis=a)
    gamma = poly.polyder(beta, axis=b)

    if i == j:
        d2phi_daidbj = lambda x: {
            1: poly.polyval,
            2: poly.polyval2d,
            3: poly.polyval3d,
        }[self.dim](*x[i], gamma)
    else:
        d2phi_daidbj = lambda x: 0.0

    return d2phi_daidbj</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential">Potential</a></b></code>:
<ul class="hlist">
<li><code><a title="trical.classes.potential.Potential.gradient" href="#trical.classes.potential.Potential.gradient">gradient</a></code></li>
<li><code><a title="trical.classes.potential.Potential.hessian" href="#trical.classes.potential.Potential.hessian">hessian</a></code></li>
<li><code><a title="trical.classes.potential.Potential.update_params" href="#trical.classes.potential.Potential.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="trical.classes.potential.Potential"><code class="flex name class">
<span>class <span class="ident">Potential</span></span>
<span>(</span><span>phi, dphi, d2phi, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Object representing a general potential</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt>d2phi (func(str,str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that</dt>
<dt>takes two strings representing the derivative variables and outputs the function</dt>
<dt>corresponding to the derivative of the potential with respect to the derivative</dt>
<dt><strong><code>variables</code></strong></dt>
<dd>&nbsp;</dd>
<dt>dphi (func(str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that</dt>
<dt>takes a string representing the derivative variable and outputs the function</dt>
<dt>corresponding to the derivative of the potential with respect to the derivative</dt>
<dt><strong><code>variable</code></strong></dt>
<dd>&nbsp;</dd>
<dt>phi (func(1-D or 2-D array of float)): Function representing the potential</dt>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Other relevant parameters of the Potential object</dd>
</dl>
<p>Initialization function for a Potential object</p>
<h2 id="args">Args</h2>
<p>phi (func(1-D or 2-D array of float)): Function representing the potential
dphi (func(str,str) -&gt; (func(1-D or 2-D array of float) -&gt; float)):
Function that takes a string representing the derivative variable and outputs
the function corresponding to the derivative of the potential with respect to
the derivative variable
d2phi (func(str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that
takes two strings representing the derivative variables and outputs the function
corresponding to the derivative of the potential with respect to the
derivative variables</p>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of the system</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Mass of an ion</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of Ions</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Charge of an ion</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Potential(object):

    &#34;&#34;&#34;
    Object representing a general potential

    Attributes:
        d2phi (func(str,str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that
        takes two strings representing the derivative variables and outputs the function
        corresponding to the derivative of the potential with respect to the derivative
        variables
        dphi (func(str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that
        takes a string representing the derivative variable and outputs the function
        corresponding to the derivative of the potential with respect to the derivative
        variable
        phi (func(1-D or 2-D array of float)): Function representing the potential
        params (dict): Other relevant parameters of the Potential object
    &#34;&#34;&#34;

    def __init__(self, phi, dphi, d2phi, **kwargs):
        &#34;&#34;&#34;
        Initialization function for a Potential object

        Args:
            phi (func(1-D or 2-D array of float)): Function representing the potential
            dphi (func(str,str) -&gt; (func(1-D or 2-D array of float) -&gt; float)):
            Function that takes a string representing the derivative variable and outputs
            the function corresponding to the derivative of the potential with respect to
            the derivative variable
            d2phi (func(str) -&gt; (func(1-D or 2-D array of float) -&gt; float)): Function that
            takes two strings representing the derivative variables and outputs the function
            corresponding to the derivative of the potential with respect to the
            derivative variables

        Kwargs:
            dim (int, optional): Dimension of the system
            m (float, optional): Mass of an ion
            N (int, optional): Number of Ions
            q (float, optional): Charge of an ion

        &#34;&#34;&#34;
        super(Potential, self).__init__()

        self.phi = phi
        self.dphi = dphi
        self.d2phi = d2phi

        params = {&#34;dim&#34;: 3}
        params.update(kwargs)
        self.__dict__.update(params)
        self.params = params
        pass

    def __add__(self, other):
        &#34;&#34;&#34;
        Adds two Potential objects

        Args:
            other (Potential): Potential object of interest

        Returns:
            Potential: Addition of the potentials
        &#34;&#34;&#34;
        for i in intersection(self.params.keys(), other.params.keys()):
            assert self.params[i] == other.params[i]

        params = {}
        params.update(self.params)
        params.update(other.params)
        phi = lambda x: self.phi(x) + other.phi(x)
        dphi = lambda var: (lambda x: self.dphi(var)(x) + other.dphi(var)(x))
        d2phi = lambda var1, var2: (
            lambda x: self.d2phi(var1, var2)(x) + other.d2phi(var1, var2)(x)
        )
        return Potential(phi, dphi, d2phi, **params)

    def __sub__(self, other):
        &#34;&#34;&#34;
        Subtracts two Potential objects

        Args:
            other (Potential): Potential object of interest

        Returns:
            Potential: Subtraction of the potentials
        &#34;&#34;&#34;
        for i in intersection(self.params.keys(), other.params.keys()):
            assert self.params[i] == other.params[i]

        params = {}
        params.update(self.params)
        params.update(other.params)
        phi = lambda x: self.phi(x) - other.phi(x)
        dphi = lambda var: (lambda x: self.dphi(var)(x) - other.dphi(var)(x))
        d2phi = lambda var1, var2: (
            lambda x: self.d2phi(var1, var2)(x) - other.d2phi(var1, var2)(x)
        )
        return Potential(phi, dphi, d2phi, **params)

    def __mul__(self, multiplier):
        &#34;&#34;&#34;
        Multiplies Potential objects by some multiplier

        Args:
            multiplier (float): Scalar to multiply the potential by

        Returns:
            Potential: The potential multiplied by the multiplier
        &#34;&#34;&#34;
        phi = lambda x: self.phi(x) * multiplier
        dphi = lambda var: (lambda x: self.dphi(var)(x) * multiplier)
        d2phi = lambda var1, var2: (lambda x: self.d2phi(var1, var2)(x) * multiplier)
        return Potential(phi, dphi, d2phi, **self.params)

    def __rmul__(self, multiplier):
        &#34;&#34;&#34;
        Multiplies Potential objects by some multiplier

        Args:
            multiplier (float): Scalar to multiply the potential by

        Returns:
            Potential: The potential multiplied by the multiplier
        &#34;&#34;&#34;
        return self * multiplier

    def __truediv__(self, divisor):
        &#34;&#34;&#34;
        Divides Potential objects by some divisor

        Args:
            divisor (float): Scalar to divide the potential by

        Returns:
            Potential: The potential divided by the divisor
        &#34;&#34;&#34;
        phi = lambda x: self.phi(x) / divisor
        dphi = lambda var: (lambda x: self.dphi(var)(x) / divisor)
        d2phi = lambda var1, var2: (lambda x: self.d2phi(var1, var2)(x) / divisor)
        return Potential(phi, dphi, d2phi, **self.params)

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the potential given the position of the ions
        &#34;&#34;&#34;
        return self.phi(x)

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the potential with respect to a variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the potential with respect to the derivative variable
        &#34;&#34;&#34;
        return self.dphi(var)

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the potential with respect to two variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the potential with respect to the derivative variables
        &#34;&#34;&#34;
        return self.d2phi(var1, var2)

    def gradient(self):
        &#34;&#34;&#34;
        Calculates the gradient of the potential

        Returns:
            func(1-D or 2-D array of float) -&gt; 1-D array of float: Function corresponding
            to the gradient of the potential
        &#34;&#34;&#34;

        def grad_phi(x):
            &#34;&#34;&#34;
            Function corresponding to the gradient of the potential

            Args:
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                1-D array of float: Value of the gradient of the potential given the
                position of the ions
            &#34;&#34;&#34;
            grad_phi_x = np.empty(self.N * self.dim)

            i = 0
            for var in itr.product(
                [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
            ):
                grad_phi_x[i] = self.dphi(var)(x)
                i += 1
            return grad_phi_x

        return grad_phi

    def hessian(self):
        &#34;&#34;&#34;
        Calculates the Hessian of the potential

        Returns:
            func(1-D or 2-D array of float) -&gt; 2-D array of float: Function corresponding
            to the Hessian of the potential
        &#34;&#34;&#34;

        def hess_phi(x):
            &#34;&#34;&#34;
            Function corresponding to the Hessian of the potential

            Args:s
                x (1-D or 2-D array of float): Position of the ions

            Returns:
                1-D array of float: Value of the Hessian of the potential given the
                position of the ions
            &#34;&#34;&#34;
            hess_phi_x = np.empty((self.N * self.dim, self.N * self.dim))

            i = 0
            for var1 in itr.product(
                [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
            ):
                j = 0
                for var2 in itr.product(
                    [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
                ):
                    hess_phi_x[i, j] = self.d2phi(var1, var2)(x)
                    j += 1
                i += 1
            return hess_phi_x

        return hess_phi

    def update_params(self, **kwargs):
        &#34;&#34;&#34;
        Updates parameters of Potential object

        Kwargs:
            dim (int, optional): Dimension of the system
            m (float, optional): Mass of an ion
            N (int, optional): Number of Ions
            q (float, optional): Charge of an ion

        &#34;&#34;&#34;
        self.params.update(kwargs)
        self.__dict__.update(self.params)
        pass

    pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="trical.classes.potential.CoulombPotential" href="#trical.classes.potential.CoulombPotential">CoulombPotential</a></li>
<li><a title="trical.classes.potential.PolynomialPotential" href="#trical.classes.potential.PolynomialPotential">PolynomialPotential</a></li>
<li><a title="trical.classes.potential.SymbolicPotential" href="#trical.classes.potential.SymbolicPotential">SymbolicPotential</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="trical.classes.potential.Potential.first_derivative"><code class="name flex">
<span>def <span class="ident">first_derivative</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the first derivative of the potential with respect to a variable</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code></dt>
<dd>Derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>first</code> <code>derivative</code> of <code>the</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code> <code>variable</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_derivative(self, var):
    &#34;&#34;&#34;
    Calculates the first derivative of the potential with respect to a variable

    Args:
        var (str): Derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        first derivative of the potential with respect to the derivative variable
    &#34;&#34;&#34;
    return self.dphi(var)</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.Potential.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the gradient of the potential</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>1</code>-<code>D</code> <code>array</code> of <code>float</code>: <code>Function</code> <code>corresponding</code></dt>
<dd>&nbsp;</dd>
<dt><code>to</code> <code>the</code> <code>gradient</code> of <code>the</code> <code>potential</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient(self):
    &#34;&#34;&#34;
    Calculates the gradient of the potential

    Returns:
        func(1-D or 2-D array of float) -&gt; 1-D array of float: Function corresponding
        to the gradient of the potential
    &#34;&#34;&#34;

    def grad_phi(x):
        &#34;&#34;&#34;
        Function corresponding to the gradient of the potential

        Args:
            x (1-D or 2-D array of float): Position of the ions

        Returns:
            1-D array of float: Value of the gradient of the potential given the
            position of the ions
        &#34;&#34;&#34;
        grad_phi_x = np.empty(self.N * self.dim)

        i = 0
        for var in itr.product(
            [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
        ):
            grad_phi_x[i] = self.dphi(var)(x)
            i += 1
        return grad_phi_x

    return grad_phi</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.Potential.hessian"><code class="name flex">
<span>def <span class="ident">hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the Hessian of the potential</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>: <code>Function</code> <code>corresponding</code></dt>
<dd>&nbsp;</dd>
<dt><code>to</code> <code>the</code> <code>Hessian</code> of <code>the</code> <code>potential</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hessian(self):
    &#34;&#34;&#34;
    Calculates the Hessian of the potential

    Returns:
        func(1-D or 2-D array of float) -&gt; 2-D array of float: Function corresponding
        to the Hessian of the potential
    &#34;&#34;&#34;

    def hess_phi(x):
        &#34;&#34;&#34;
        Function corresponding to the Hessian of the potential

        Args:s
            x (1-D or 2-D array of float): Position of the ions

        Returns:
            1-D array of float: Value of the Hessian of the potential given the
            position of the ions
        &#34;&#34;&#34;
        hess_phi_x = np.empty((self.N * self.dim, self.N * self.dim))

        i = 0
        for var1 in itr.product(
            [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
        ):
            j = 0
            for var2 in itr.product(
                [&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][: self.dim], np.arange(1, self.N + 1, dtype=int)
            ):
                hess_phi_x[i, j] = self.d2phi(var1, var2)(x)
                j += 1
            i += 1
        return hess_phi_x

    return hess_phi</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.Potential.second_derivative"><code class="name flex">
<span>def <span class="ident">second_derivative</span></span>(<span>self, var1, var2)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the second derivative of the potential with respect to two variables</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var1</code></strong> :&ensp;<code>str</code></dt>
<dd>first derivative variable</dd>
<dt><strong><code>var2</code></strong> :&ensp;<code>str</code></dt>
<dd>second derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>second</code> <code>derivative</code> of <code>the</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code> <code>variables</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative(self, var1, var2):
    &#34;&#34;&#34;
    Calculates the second derivative of the potential with respect to two variables

    Args:
        var1 (str): first derivative variable
        var2 (str): second derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        second derivative of the potential with respect to the derivative variables
    &#34;&#34;&#34;
    return self.d2phi(var1, var2)</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.Potential.update_params"><code class="name flex">
<span>def <span class="ident">update_params</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Updates parameters of Potential object</p>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of the system</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Mass of an ion</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of Ions</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Charge of an ion</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_params(self, **kwargs):
    &#34;&#34;&#34;
    Updates parameters of Potential object

    Kwargs:
        dim (int, optional): Dimension of the system
        m (float, optional): Mass of an ion
        N (int, optional): Number of Ions
        q (float, optional): Charge of an ion

    &#34;&#34;&#34;
    self.params.update(kwargs)
    self.__dict__.update(self.params)
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trical.classes.potential.SymbolicPotential"><code class="flex name class">
<span>class <span class="ident">SymbolicPotential</span></span>
<span>(</span><span>expr, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Object representing a symbolically defined potential</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>expr</code></strong> :&ensp;<code>sympy</code></dt>
<dd>Symbolic expression of the potential</dd>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of the system</dd>
</dl>
<p>Initialization function for a SymbolicPotential object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expr</code></strong> :&ensp;<code>sympy</code></dt>
<dd>Symbolic expression of the potential</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of the system</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SymbolicPotential(Potential):

    &#34;&#34;&#34;
    Object representing a symbolically defined potential

    Attributes:
        expr (sympy): Symbolic expression of the potential
        dim (int, optional): Dimension of the system
    &#34;&#34;&#34;

    def __init__(self, expr, **kwargs):
        &#34;&#34;&#34;
        Initialization function for a SymbolicPotential object

        Args:
            expr (sympy): Symbolic expression of the potential
        Kwargs:
            dim (int, optional): Dimension of the system
        &#34;&#34;&#34;
        self.expr = expr

        params = {&#34;dim&#34;: 3}
        params.update(kwargs)
        self.__dict__.update(params)
        self.params = params

        self.symbol = [sympy.Symbol([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;][i]) for i in range(self.dim)]
        self.lambdified_expr = sympy.utilities.lambdify(self.symbol, expr)

        super(SymbolicPotential, self).__init__(
            self.__call__, self.first_derivative, self.second_derivative, **params
        )
        pass

    def __call__(self, x):
        &#34;&#34;&#34;
        Evaluates the symbolically defined potential given the position of the ions

        Args:
            x (1-D or 2-D array of floats): Position of the ions

        Returns:
            float: value of the symbolically defined potential given the position of the ions
        &#34;&#34;&#34;
        return self.lambdified_expr(*x.transpose()).sum()

    def first_derivative(self, var):
        &#34;&#34;&#34;
        Calculates the first derivative of the symbolically defined potential with respect to a
        variable

        Args:
            var (str): Derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            first derivative of the symbolically defined potential with respect to the derivative
            variable
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
        i = int(var[1:] if type(var) == str else var[1:][0]) - 1

        dphi_dai = lambda x: sympy.utilities.lambdify(
            self.symbol, sympy.diff(self.expr, self.symbol[a])
        )(*x[i])

        return dphi_dai

    def second_derivative(self, var1, var2):
        &#34;&#34;&#34;
        Calculates the second derivative of the symbolically defined potential with respect to two
        variables

        Args:
            var1 (str): first derivative variable
            var2 (str): second derivative variable

        Returns:
            func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
            second derivative of the symbolically defined potential with respect to the derivative
            variables
        &#34;&#34;&#34;
        a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
        b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
        i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
        j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

        if i == j:
            d2phi_daidbj = lambda x: sympy.utilities.lambdify(
                self.symbol, sympy.diff(self.expr, self.symbol[a], self.symbol[b])
            )(*x[i])
        else:
            d2phi_daidbj = lambda x: 0

        return d2phi_daidbj

    def nondimensionalize(self, l):
        &#34;&#34;&#34;
        Nondimensionalizes the symbolically defined potential using a length scale

        Args:
            l (float): A length scale

        Returns:
            PolynomialPotential: Nondimensionalized symbolically defined potential
        &#34;&#34;&#34;
        expr = self.expr.subs({k: k * l for k in self.symbol}) * (
            l / (cst.k * cst.e ** 2)
        )
        return SymbolicPotential(expr, **self.params)

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential">Potential</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="trical.classes.potential.SymbolicPotential.first_derivative"><code class="name flex">
<span>def <span class="ident">first_derivative</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the first derivative of the symbolically defined potential with respect to a
variable</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code></dt>
<dd>Derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>first</code> <code>derivative</code> of <code>the</code> <code>symbolically</code> <code>defined</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code></dt>
<dd>&nbsp;</dd>
<dt><code>variable</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_derivative(self, var):
    &#34;&#34;&#34;
    Calculates the first derivative of the symbolically defined potential with respect to a
    variable

    Args:
        var (str): Derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        first derivative of the symbolically defined potential with respect to the derivative
        variable
    &#34;&#34;&#34;
    a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var[0]]
    i = int(var[1:] if type(var) == str else var[1:][0]) - 1

    dphi_dai = lambda x: sympy.utilities.lambdify(
        self.symbol, sympy.diff(self.expr, self.symbol[a])
    )(*x[i])

    return dphi_dai</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.SymbolicPotential.nondimensionalize"><code class="name flex">
<span>def <span class="ident">nondimensionalize</span></span>(<span>self, l)</span>
</code></dt>
<dd>
<section class="desc"><p>Nondimensionalizes the symbolically defined potential using a length scale</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>A length scale</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="trical.classes.potential.PolynomialPotential" href="#trical.classes.potential.PolynomialPotential"><code>PolynomialPotential</code></a></strong></dt>
<dd>Nondimensionalized symbolically defined potential</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nondimensionalize(self, l):
    &#34;&#34;&#34;
    Nondimensionalizes the symbolically defined potential using a length scale

    Args:
        l (float): A length scale

    Returns:
        PolynomialPotential: Nondimensionalized symbolically defined potential
    &#34;&#34;&#34;
    expr = self.expr.subs({k: k * l for k in self.symbol}) * (
        l / (cst.k * cst.e ** 2)
    )
    return SymbolicPotential(expr, **self.params)</code></pre>
</details>
</dd>
<dt id="trical.classes.potential.SymbolicPotential.second_derivative"><code class="name flex">
<span>def <span class="ident">second_derivative</span></span>(<span>self, var1, var2)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the second derivative of the symbolically defined potential with respect to two
variables</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var1</code></strong> :&ensp;<code>str</code></dt>
<dd>first derivative variable</dd>
<dt><strong><code>var2</code></strong> :&ensp;<code>str</code></dt>
<dd>second derivative variable</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>func</code>(<code>1</code>-<code>D</code> or <code>2</code>-<code>D</code> <code>array</code> of <code>float</code>) -&gt; <code>float</code>: <code>Function</code> <code>corresponding</code> <code>to</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>second</code> <code>derivative</code> of <code>the</code> <code>symbolically</code> <code>defined</code> <code>potential</code> <code>with</code> <code>respect</code> <code>to</code> <code>the</code> <code>derivative</code></dt>
<dd>&nbsp;</dd>
<dt><code>variables</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_derivative(self, var1, var2):
    &#34;&#34;&#34;
    Calculates the second derivative of the symbolically defined potential with respect to two
    variables

    Args:
        var1 (str): first derivative variable
        var2 (str): second derivative variable

    Returns:
        func(1-D or 2-D array of float) -&gt; float: Function corresponding to the
        second derivative of the symbolically defined potential with respect to the derivative
        variables
    &#34;&#34;&#34;
    a = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var1[0]]
    b = {&#34;x&#34;: 0, &#34;y&#34;: 1, &#34;z&#34;: 2}[var2[0]]
    i = int(var1[1:] if type(var1) == str else var1[1:][0]) - 1
    j = int(var2[1:] if type(var2) == str else var2[1:][0]) - 1

    if i == j:
        d2phi_daidbj = lambda x: sympy.utilities.lambdify(
            self.symbol, sympy.diff(self.expr, self.symbol[a], self.symbol[b])
        )(*x[i])
    else:
        d2phi_daidbj = lambda x: 0

    return d2phi_daidbj</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential">Potential</a></b></code>:
<ul class="hlist">
<li><code><a title="trical.classes.potential.Potential.gradient" href="#trical.classes.potential.Potential.gradient">gradient</a></code></li>
<li><code><a title="trical.classes.potential.Potential.hessian" href="#trical.classes.potential.Potential.hessian">hessian</a></code></li>
<li><code><a title="trical.classes.potential.Potential.update_params" href="#trical.classes.potential.Potential.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="trical.classes" href="index.html">trical.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="trical.classes.potential.CoulombPotential" href="#trical.classes.potential.CoulombPotential">CoulombPotential</a></code></h4>
<ul class="">
<li><code><a title="trical.classes.potential.CoulombPotential.first_derivative" href="#trical.classes.potential.CoulombPotential.first_derivative">first_derivative</a></code></li>
<li><code><a title="trical.classes.potential.CoulombPotential.nondimensionalize" href="#trical.classes.potential.CoulombPotential.nondimensionalize">nondimensionalize</a></code></li>
<li><code><a title="trical.classes.potential.CoulombPotential.second_derivative" href="#trical.classes.potential.CoulombPotential.second_derivative">second_derivative</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trical.classes.potential.PolynomialPotential" href="#trical.classes.potential.PolynomialPotential">PolynomialPotential</a></code></h4>
<ul class="">
<li><code><a title="trical.classes.potential.PolynomialPotential.first_derivative" href="#trical.classes.potential.PolynomialPotential.first_derivative">first_derivative</a></code></li>
<li><code><a title="trical.classes.potential.PolynomialPotential.nondimensionalize" href="#trical.classes.potential.PolynomialPotential.nondimensionalize">nondimensionalize</a></code></li>
<li><code><a title="trical.classes.potential.PolynomialPotential.second_derivative" href="#trical.classes.potential.PolynomialPotential.second_derivative">second_derivative</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trical.classes.potential.Potential" href="#trical.classes.potential.Potential">Potential</a></code></h4>
<ul class="">
<li><code><a title="trical.classes.potential.Potential.first_derivative" href="#trical.classes.potential.Potential.first_derivative">first_derivative</a></code></li>
<li><code><a title="trical.classes.potential.Potential.gradient" href="#trical.classes.potential.Potential.gradient">gradient</a></code></li>
<li><code><a title="trical.classes.potential.Potential.hessian" href="#trical.classes.potential.Potential.hessian">hessian</a></code></li>
<li><code><a title="trical.classes.potential.Potential.second_derivative" href="#trical.classes.potential.Potential.second_derivative">second_derivative</a></code></li>
<li><code><a title="trical.classes.potential.Potential.update_params" href="#trical.classes.potential.Potential.update_params">update_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trical.classes.potential.SymbolicPotential" href="#trical.classes.potential.SymbolicPotential">SymbolicPotential</a></code></h4>
<ul class="">
<li><code><a title="trical.classes.potential.SymbolicPotential.first_derivative" href="#trical.classes.potential.SymbolicPotential.first_derivative">first_derivative</a></code></li>
<li><code><a title="trical.classes.potential.SymbolicPotential.nondimensionalize" href="#trical.classes.potential.SymbolicPotential.nondimensionalize">nondimensionalize</a></code></li>
<li><code><a title="trical.classes.potential.SymbolicPotential.second_derivative" href="#trical.classes.potential.SymbolicPotential.second_derivative">second_derivative</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>