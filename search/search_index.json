{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TrICal","text":"<p>TrICal (Trapped-Ion Calculator) is a python package for simulating trapped-ion physics.</p> <p>Warning</p> <p>TrICal is still currently in heavy development, breaking changes might be made! Refer to Features in development.</p> <p>Given a description of a trapped-ion experiment with:</p> <ul> <li>\\(N\\) ions in a chain<ul> <li>\\(J\\) specified levels each</li> </ul> </li> <li>\\(M\\) lasers</li> <li>\\(L\\) motional modes</li> </ul> <p>Goal</p> <ol> <li>TrICal constructs the system Hamiltonian.</li> <li>Applies approximations to the system Hamiltonian.</li> <li>Connects with a quantum simulation backend (e.g. QuTiP) to perform simulations.</li> </ol> <p></p> <p>TrICal is developed under Open Quantum Design (OQD) as a component of the OQD open-source full stack quantum computer with trapped-ions.</p> <p></p>"},{"location":"explanation/backends/","title":"Backends","text":"<p>Backends are used to execute the AtomicCircuit.</p>"},{"location":"explanation/backends/#supported-backends","title":"Supported Backends","text":"<ul> <li>QuTiP </li> <li>Dynamiqs </li> </ul>"},{"location":"explanation/backends/#compile","title":"Compile","text":"<p>Compiles the AtomicCircuit into a compatible form for the backend to run on.</p> <p>Examples</p> <ul> <li>QuTiP requires the AtomicCircuit be compiled to a <code>QutipExperiment</code>.</li> <li>Dynamiqs requires the AtomicCircuit be compiled to a <code>DynamiqsExperiment</code>.</li> </ul>"},{"location":"explanation/backends/#run","title":"Run","text":"<p>Executes the compatible form of the AtomicCircuit with the backend using a tree walking interpreter.</p> <p>Examples</p> <ul> <li>QuTiP uses <code>QutipVM</code> as its tree walking interpreter.</li> <li>Dynamiqs uses <code>DynamiqsVM</code> as its tree walking interpreter.</li> </ul>"},{"location":"explanation/mechanical_properties/","title":"Mechanical Properties of Ion Crystals","text":""},{"location":"explanation/mechanical_properties/#potential","title":"Potential","text":"<p>In a system of trapped ions, the ions experience the following potentials:</p> \\[     \\Phi = \\Phi_{\\mathrm{Coulomb}} + \\Phi_{\\mathrm{Trap}} \\] <ul> <li>\\(\\Phi_{\\mathrm{Coulomb}} \\equiv\\) Coulomb potential.</li> <li>\\(\\Phi_{\\mathrm{Trap}} \\equiv\\) Trapping potential.</li> </ul> <p>The trapping potential can be generated with:</p> <ul> <li>Combination of static (DC) and dynamic (RF) electric fields</li> <li>Optical fields (e.g. optical cavity, optical tweezers)</li> </ul>"},{"location":"explanation/mechanical_properties/#equilibrium-position","title":"Equilibrium Position","text":"<p>Calculating the equilibrium position of the ions corresponds to:</p> \\[ \\{\\mathbf{r}_{i}^*\\}_i^N = \\mathrm{argmin}_{\\{\\mathbf{r}_{i}\\}_i^N} \\Phi\\left(\\{\\mathbf{r}_{i}\\}_i^N\\right) \\] <ul> <li>\\(\\{\\mathbf{r}_{i}\\}_i^N \\equiv\\) Position of the ions.</li> <li>\\(\\{\\mathbf{r}_{i}^*\\}_i^N \\equiv\\) Equilibrium position of the ions.</li> </ul>"},{"location":"explanation/mechanical_properties/#vibrational-modes","title":"Vibrational Modes","text":"<p>Calculating the vibrational (phonon) modes corresponds to:</p> \\[ \\begin{aligned} A &amp;= \\mathrm{Hess}[\\Phi]\\left(\\{\\mathbf{r}_{i}^*\\}_i^N\\right) \\\\ A &amp;= B^* D B \\end{aligned} \\] <ul> <li>\\(B \\equiv\\) Eigenvector matrix for the ion crystal.</li> <li>\\(D \\equiv\\) Diagonal matrix containing eigenvalues for the ion crystal.</li> </ul>"},{"location":"explanation/reference/","title":"Reference","text":""},{"location":"explanation/reference/#quantum-dynamics-of-single-trapped-ions","title":"Quantum dynamics of single trapped ions","text":"<pre><code>@article{leibfried_quantum_2003,\ntitle = {Quantum dynamics of single trapped ions},\nvolume = {75},\nurl = {https://link.aps.org/doi/10.1103/RevModPhys.75.281},\ndoi = {10.1103/RevModPhys.75.281},\nabstract = {Single trapped ions represent elementary quantum systems that are well isolated from the environment. They can be brought nearly to rest by laser cooling, and both their internal electronic states and external motion can be coupled to and manipulated by light fields. This makes them ideally suited for quantum-optical and quantum-dynamical studies under well-controlled conditions. Theoretical and experimental work on these topics is reviewed in the paper, with a focus on ions trapped in radio-frequency (Paul) traps.},\nnumber = {1},\nurldate = {2024-09-04},\njournal = {Reviews of Modern Physics},\nauthor = {Leibfried, D. and Blatt, R. and Monroe, C. and Wineland, D.},\nmonth = mar,\nyear = {2003},\nnote = {Publisher: American Physical Society},\npages = {281--324},\nfile = {APS Snapshot:C\\:\\\\Users\\\\Salieri\\\\Zotero\\\\storage\\\\SF4FPDHB\\\\RevModPhys.75.html:text/html;Full Text PDF:C\\:\\\\Users\\\\Salieri\\\\Zotero\\\\storage\\\\LCRZRSV4\\\\Leibfried et al. - 2003 - Quantum dynamics of single trapped ions.pdf:application/pdf},\n}\n</code></pre>"},{"location":"explanation/reference/#ordered-expansions-in-boson-amplitude-operators","title":"Ordered expansions in boson amplitude operators","text":"<pre><code>@article{cahill_ordered_1969,\ntitle = {Ordered {Expansions} in {Boson} {Amplitude} {Operators}},\nvolume = {177},\nurl = {https://link.aps.org/doi/10.1103/PhysRev.177.1857},\ndoi = {10.1103/PhysRev.177.1857},\nabstract = {The expansion of operators as ordered power series in the annihilation and creation operators \ud835\udc4e and \ud835\udc4e\u2020 is examined. It is found that normally ordered power series exist and converge quite generally, but that for the case of antinormal ordering the required \ud835\udc50-number coefficients are infinite for important classes of operators. A parametric ordering convention is introduced according to which normal, symmetric, and antinormal ordering correspond to the values \ud835\udc60=+1,0,\u22121, respectively, of an order parameter \ud835\udc60. In terms of this convention it is shown that for bounded operators the coefficients are finite when \ud835\udc60{\\textgreater}0, and the series are convergent when \ud835\udc60{\\textgreater}12. For each value of the order parameter \ud835\udc60, a correspondence between operators and \ud835\udc50-number functions is defined. Each correspondence is one-to-one and has the property that the function \ud835\udc53\u2061(\ud835\udefc) associated with a given operator \ud835\udc39 is the one which results when the operators \ud835\udc4e and \ud835\udc4e\u2020 occurring in the ordered power series for \ud835\udc39 are replaced by their complex eigenvalues \ud835\udefc and \ud835\udefc\\*. The correspondence which is realized for symmetric ordering is the Weyl correspondence. The operators associated by each correspondence with the set of \ud835\udeff functions on the complex plane are discussed in detail. They are shown to furnish, for each ordering, an operator basis for an integral representation for arbitrary operators. The weight functions in these representations are simply the functions that correspond to the operators being expanded. The representation distinguished by antinormal ordering expresses operators as integrals of projection operators upon the coherent states, which is the form taken by the \ud835\udc43 representation for the particular case of the density operator. The properties of the full set of representations are discussed and are shown to vary markedly with the order parameter \ud835\udc60.},\nnumber = {5},\nurldate = {2024-09-04},\njournal = {Physical Review},\nauthor = {Cahill, K. E. and Glauber, R. J.},\nmonth = jan,\nyear = {1969},\nnote = {Publisher: American Physical Society},\npages = {1857--1881},\nfile = {Full Text PDF:C\\:\\\\Users\\\\Salieri\\\\Zotero\\\\storage\\\\VIPIQIPJ\\\\Cahill and Glauber - 1969 - Ordered Expansions in Boson Amplitude Operators.pdf:application/pdf},\n}\n</code></pre>"},{"location":"explanation/reference/#atomic-physics","title":"Atomic Physics","text":"<pre><code>@book{foot_atomic_2005,\ntitle = {Atomic {Physics}},\nisbn = {978-0-19-850695-9},\nabstract = {This text will thoroughly update the existing literature on atomic physics. Intended to accompany an advanced undergraduate course in atomic physics, the book will lead the students up to the latest advances and the applications to Bose-Einstein Condensation of atoms, matter-wave inter-ferometry and quantum computing with trapped ions. The elementary atomic physics covered in the early chapters should be accessible to undergraduates when they are first introduced to the subject. To complement the usual quantum mechanical treatment of atomic structure the book strongly emphasizes the experimental basis of the subject, especially in the later chapters. It includes ample tutorial material (examples, illustrations, chapter summaries, graded problem sets).},\nlanguage = {en},\npublisher = {Oxford University Press},\nauthor = {Foot, C. J.},\nyear = {2005},\nnote = {Google-Books-ID: \\_CoSDAAAQBAJ},\nkeywords = {Science / Physics / Atomic \\&amp; Molecular, Science / Physics / General, Science / Physics / Nuclear, Science / Physics / Optics \\&amp; Light, Science / Physics / Quantum Theory, Technology \\&amp; Engineering / Lasers \\&amp; Photonics},\n}\n</code></pre>"},{"location":"explanation/approximations/adiabatic_elimination/","title":"Adiabatic Elimination","text":"<p>The adiabatic elimination step serves to ignore negligible physics that may result in long simulation run times or simulations being aborted entirely by QuTiP.</p>"},{"location":"explanation/approximations/adiabatic_elimination/#single-photon-adiabatic-elimination","title":"Single-Photon Adiabatic Elimination","text":"<p>A simple example of this in action is a three level system \\(|0\\rangle, |1\\rangle, |2\\rangle\\) in an ion being addressed by a single laser, resonant on the \\(|0\\rangle \\leftrightarrow |1\\rangle\\) transition. The full Hamiltonian predicts coupling between all pairs of levels (assuming their transitions are all allowed, hence single-photon).</p> <p></p> <p>It also predicts that \\(\\Delta_{0002}\\) and \\(\\Delta_{0012}\\) will be large since the laser is far-detuned from these transitions (refer to Section 2.1 for subscript meanings). Because the probability \\(P\\) of exciting the transition goes as \\(\\frac{\\Omega^2}{\\Delta^2}\\) for large \\(\\Delta\\), we expect transitions into level 2 to be extremely unlikely.</p> <p>As such, a RewriteRule named AdiabaticElimination is tasked with traversing the Hamiltonian tree, and if \\(\\Omega_{00ij}^2 / \\Delta_{00ij}^2 \\ll\\) than the user-defined threshold, it will remove all terms coupling levels \\(i\\) and \\(j\\) (\\(|i\\rangle\\langle j|\\)). This has the same effect as simply removing \\(|2\\rangle\\) from the Hilbert space entirely as far as levels 0 and 1 are concerned.</p>"},{"location":"explanation/approximations/adiabatic_elimination/#raman-transitions","title":"Raman Transitions","text":"<p>In Progress</p> <p>Raman transitions make use of a third level to drive transitions that cannot be driven directly. We'll consider a three level \\(\\Lambda\\) system, irradiated by two lasers, where we'd like to drive population between \\(|0\\rangle\\) and \\(|1\\rangle\\), and we'll use virtual absorption and emission of photons from \\(|0\\rangle\\) to do so:</p> <p></p> <p>These transitions can be difficult to simulate because they rely on a large \\(\\Delta\\) that is usually many orders of magnitude larger than the relevant simulation timescales, specifically the effective Rabi frequency between \\(|0\\rangle\\) and \\(|1\\rangle\\). This discrepancy in timescale makes QuTiP's integrator have to take small time steps to try and resolve quickly-evolving dynamics introduced by \\(\\Delta\\), resulting in very slow simulation times or calls to the integrator being aborted.</p> <p>Thus, instead of simulating the full Hamiltonian, we must replace the parts of the tree corresponding to the \\(\\Lambda\\) system with an effective two-level Hamiltonian:</p> \\[     H_{\\text{eff}} = \\frac{\\hbar\\Omega_{\\text{eff}}}{2}e^{-i\\delta_{\\text{eff}} t}|1\\rangle\\langle 0|D(\\alpha_{\\text{eff}}) + H.C. \\] <p>where</p> \\[     \\Omega_{\\text{eff}} = \\frac{\\Omega_{02}\\Omega_{12}}{2\\Delta}\\text{,    } \\vec{k}_{\\text{eff}} = \\vec{k}_1 - \\vec{k}_2 \\] <p>which takes on the familiar form of a two-level system being addressed by a single laser with wavevector \\(\\vec{k}_{\\text{eff}}\\) and detuning \\(\\delta_{\\text{eff}}\\).</p> <p>\\(\\vec{k}_{\\text{eff}}\\) is relevant for preserving coupling to the motional modes. In Section 2.1, we used the fact that \\(\\vec{k}\\cdot\\vec{r} = \\eta(a^{\\dagger} + a)\\) to arrive at the displacement operator \\(D(\\alpha)\\), noting that \\(\\eta\\) depends on the laser's wavevector. As such, our modified displacement operator becomes:</p> \\[     \\begin{align}     D(\\alpha_{\\text{eff}}) &amp;= \\exp \\left(i(\\vec{k}_1 - \\vec{k}_2)\\cdot\\vec{r}\\right)\\\\     &amp;= \\exp \\left(i(\\eta_1(a^{\\dagger} + a) - \\eta_2(a^{\\dagger} + a))\\right)     \\end{align} \\] <p>After performing our usual transformation into the interaction picture,</p> \\[     \\begin{align}     D(\\alpha_{\\text{eff}}) &amp;= \\exp \\left(i(\\eta_1(e^{i\\nu t} a^{\\dagger} + e^{-i\\nu t}a) - \\eta_2(e^{i\\nu t}a^{\\dagger} + e^{-i\\nu t}a))\\right)\\\\     &amp;= \\exp(\\alpha_1 a^{\\dagger} - \\alpha_1^{*}a - \\alpha_2 a^{\\dagger} + \\alpha_2^{*}a)\\\\     &amp;= \\exp\\left((\\alpha_1-\\alpha_2)a^{\\dagger} - (\\alpha_1 - \\alpha_2)^* a\\right)\\\\     &amp;= \\exp\\left(\\alpha_{\\text{eff}}a^{\\dagger} - \\alpha_{\\text{eff}}^* a\\right)     \\end{align} \\] <p>so \\(\\alpha_{\\text{eff}} = i(\\eta_1- \\eta_2)e^{i\\nu t}\\).</p> <p>Importantly, the three levels will be light shifted by varying amounts. Specifically, the intermediate level will be shifted toward higher energies, and the other two levels will be shifted toward lower energies:</p> \\[     \\begin{align}     \\delta_0^{\\text{LS}} &amp;= -\\frac{\\Omega_{02}^2}{4\\Delta} \\\\     \\delta_1^{\\text{LS}} &amp;= -\\frac{\\Omega_{12}^2}{4(\\Delta + \\delta)} \\\\     \\delta_2^{\\text{LS}} &amp;= \\frac{\\Omega_{02}^2}{4\\Delta} + \\frac{\\Omega_{12}^2}{4(\\Delta + \\delta)}     \\end{align} \\] <p>Right now, TrICal DOES NOT account for these Stark shifts. On one hand, one can just set \\(\\delta_{\\text{eff}} = \\delta + \\Sigma_i\\delta_i^{\\text{LS}}\\), which is fine if the \\(\\Lambda\\) system is isolated (coupling only exists between these three levels when the Hamiltonian is initially constructed).</p>"},{"location":"explanation/approximations/lamb_dicke/","title":"Lamb-Dicke Approximation","text":"<p>We saw in the derivation of the system Hamiltonian that the displacement operator on a motional mode is given by</p> \\[     D(\\alpha) = \\exp(\\alpha a^{\\dagger} + \\alpha^* a)=\\exp\\left(i\\eta e^{i\\nu t}a^{\\dagger} + i\\eta e^{-i\\nu t }a\\right) \\] <p>after plugging in the definition of the coherent state parameter \\(\\alpha\\). This operator, as is, is in general difficult to simulate due to the doubly-exponentiated time-dependence on the mode frequency. However, we may retain only the first few terms in its Taylor expansion provided that certain conditions be met.</p>"},{"location":"explanation/approximations/lamb_dicke/#first-order-approximation","title":"First Order Approximation","text":"<p>For the first order condition, we consider the different ways the annihilation and creation operators can act on a Fock state \\(|n\\rangle\\) once: \\(\\eta a|n\\rangle = \\eta \\sqrt{n}  |n-1\\rangle\\), \\(\\eta a^{\\dagger}|n\\rangle = \\eta\\sqrt{n+1}|n+1\\rangle\\). Thus, the probability \\(P_1\\) of changing the number of phonons by 1 is given by</p> \\[     P_1 = (\\eta\\sqrt{n})^2 + (\\eta\\sqrt{n+1})^2 \\] <p>If \\(P_1\\) is small, we may expand \\(D(\\alpha)\\) to first order as follows:</p> <p></p> <p>Important</p> <p>If:</p> \\[     \\eta^2(2n+1) &lt;&lt; 1 \\] <p>Then:</p> \\[     D(\\alpha) \\approx \\mathbb{1} + \\alpha a^{\\dagger} + \\alpha^* a = \\mathbb{1} + i\\eta\\left(e^{i\\nu t} a^{\\dagger} + e^{-i\\nu t} a\\right) \\]"},{"location":"explanation/approximations/lamb_dicke/#second-order-approximation","title":"Second Order Approximation","text":"<p>We can play a very similiar game with the second order condition where we consider the different ways to increase the number of phonons by 2 of a Fock state:</p> \\[     \\begin{align}     \\eta^2 aa|n\\rangle &amp;= \\eta^2 \\sqrt{n(n-1)}|n-2\\rangle \\\\     \\eta^2 a^{\\dagger} a^{\\dagger} |n\\rangle &amp;= \\eta^2 \\sqrt{(n+2)(n+1)}|n+2\\rangle     \\end{align} \\] <p>Similar to above, we may expand \\(D(\\alpha)\\) to second order as follows:</p> <p></p> <p>Important</p> <p>If:</p> \\[     2\\eta^4(n^2+n+1)&lt;&lt;1 \\] <p>Then:</p> \\[     D(\\alpha) \\approx \\mathbb{1} + \\alpha a^{\\dagger} + \\alpha^* a + \\frac{1}{2}\\left(\\alpha a^{\\dagger} + \\alpha^* a\\right)^2 \\]"},{"location":"explanation/approximations/lamb_dicke/#higher-order-approximations","title":"Higher Order Approximations","text":"<p>If none of the above conditions are met, then TrICal will expand \\(D(\\alpha)\\) out to third order:</p> \\[     D(\\alpha) \\approx \\mathbb{1} + \\alpha a^{\\dagger} + \\alpha^* a + \\frac{1}{2}\\left(\\alpha a^{\\dagger} + \\alpha^* a\\right)^2 + \\frac{1}{6}\\left(\\alpha a^{\\dagger} + \\alpha^* a\\right)^3 \\]"},{"location":"explanation/approximations/lamb_dicke/#computing-dalpha-matrix-elements","title":"Computing \\(D(\\alpha)\\) Matrix Elements","text":"<p>Importantly, TrICal does not compute first and second order constriants (convert into a matrix) directly. This is because information about the oscillating terms, particular the frequency in \\(e^{\\pi \\nu t}\\), becomes difficult to retrieve when taking the RWA (described in the following section).</p> <p>Instead, the order to which we must expand is used to discard \\(D(\\alpha)\\) matrix elements, computed using Laguerre polynomials. According to Glauber and Cahill, the matrix elements of \\(D(\\alpha)\\) in the Fock basis, \\(D_{mn} \\equiv \\langle m|D(\\alpha)|n\\rangle\\), can be written as</p> <p>For \\(m \\geq n\\):</p> \\[      D_{mn} = \\sqrt{\\frac{n!}{m!}}\\alpha^{m-n}e^{-\\frac{1}{2}|\\alpha|^2}L_n^{(m-n)}(|\\alpha|^2) \\] <p>For \\(m &lt; n\\):</p> \\[     D_{mn} = \\sqrt{\\frac{m!}{n!}}(-\\alpha^*)^{n-m}e^{-\\frac{1}{2}|\\alpha|^2}L_m^{(n-m)}(|\\alpha|^2) \\] <p>Note</p> <p>The matrix elements are not computed until the abstract syntax tree representation is converted to a QuTiP-compatible object by the QutipCodeGeneration conversion rule.</p> <p>It's at this point that the Lamb-Dicke approximation, and the order we've determined we must expand to, takes effect: if \\(|m-n| &gt;\\) Lamb-Dicke order, set the matrix element to 0.</p>"},{"location":"explanation/approximations/rotating_wave/","title":"Rotating Wave Approximation (RWA)","text":"<p>The rotating wave approximation (RWA) simply states that any terms in the Hamiltonian oscillating faster than a user-specified cutoff, \\(\\omega_{\\text{cutoff}}\\), are neglected.</p> <p>Looking at the general Hamiltonian, we see that these oscillating terms will arise from the product of \\(e^{-i\\Delta_{nmjk}t}\\) and the matrix elements of \\(D(\\alpha)\\). Because we are computing these via Laguerre polynomials, it is straightforward to derive a condition on what terms must be dropped.</p> <p>Let's first consider one of these oscillating terms for when \\(m\\geq n\\). Plugging in \\(\\alpha = i\\eta e^{i\\nu t}\\) into first order Lamb-Dicke approximation, we get</p> \\[     \\begin{align}     e^{-i\\Delta_{nmjk}t} D_{mn} &amp;= e^{-i\\Delta_{nmjk}t} \\sqrt{\\frac{n!}{m!}}(i\\eta e^{i\\nu t})^{m-n}e^{-\\eta^2 /2}L_n^{(m-n)}(\\eta^2)\\\\     &amp;= \\sqrt{\\frac{n!}{m!}}(i\\eta)^{m-n}e^{i[(m-n)\\nu - \\Delta_{nmjk}]t- \\eta^2/2}L_n^{(m-n)}(\\eta^2)     \\end{align} \\] <p>So we find that these Hamiltonian matrix elements rotate at frequency \\((m-n)\\nu-\\Delta_{nmjk}\\). We find the same condition on this 'combined' frequency for the \\(m&gt;n\\) case as well</p> \\[     \\begin{align}     e^{-i\\Delta_{nmjk}t} D_{mn} &amp;= e^{-i\\Delta_{nmjk}t} \\sqrt{\\frac{m!}{n!}}(-i\\eta e^{-i\\nu t})^{n-m}e^{-\\eta^2 /2}L_m^{(n-m)}(\\eta^2)\\\\     &amp;= \\sqrt{\\frac{m!}{n!}}(-i\\eta)^{m-n}e^{-i[(n-m)\\nu + \\Delta_{nmjk}]t- \\eta^2/2}L_m^{(n-m)}(\\eta^2)     \\end{align} \\] <p>Thus, the condition on the RWA can be written as</p> \\[     \\text{If  } |(m-n)\\nu - \\Delta_{nmkj}| &lt; \\omega_{\\text{cutoff}} \\text{ , } D_{mn} \\rightarrow 0 \\]"},{"location":"explanation/hamiltonian_construction/additional/","title":"Additional Formulae","text":"<p>These formulas are often computed using helper functions as part of the Hamiltonian construction process. When this is the case, the name and location of the helper function is specified.</p> \\[     \\Omega = \\frac{\\pi}{\\tau_\\pi} \\] <ul> <li>\\(\\Omega \\equiv\\) Rabi frequency</li> <li>\\(\\tau_{\\pi} \\equiv\\) \\(\\pi\\)-time</li> </ul> \\[ I = \\frac{\\epsilon_0 c }{2}\\left(\\frac{\\hbar\\Omega}{e M_{12}}\\right)^2 \\] <ul> <li>\\(M_{12} \\equiv \\langle 1| \\hat{M}|2 \\rangle \\equiv\\) Multipole transition matrix element</li> </ul> <p>Used in intensity_from_laser and rabi_from_intensity</p> \\[     E = \\sqrt{\\frac{2I}{\\epsilon_0 c}} \\] <ul> <li>\\(I \\equiv\\) Laser intensity</li> <li>\\(E \\equiv\\) magnitude of laser E-field \\(\\vec{E}\\)</li> </ul> <p>Used in rabi_from_intensity</p> \\[ \\eta = \\vec{k}\\cdot\\hat{b}\\sqrt{\\frac{\\hbar}{2m\\nu}} \\] <ul> <li>\\(\\eta \\equiv\\) Lamb-Dicke parameter</li> <li>\\(\\vec{k} \\equiv\\) Laser wavevector</li> <li>\\(\\hat{b} \\equiv\\) Motional mode eigenvector</li> <li>\\(m \\equiv\\) Ion mass</li> <li>\\(\\nu \\equiv\\) Motional mode eigenfrequency</li> </ul> <p>Used in ConstructHamiltonian</p>"},{"location":"explanation/hamiltonian_construction/derivation/","title":"Trapped-ion System Hamiltonian Derivation","text":"<p>Goal</p> <p>Derive the general Hamiltonian of the trapped-ion system for:</p> <ul> <li>\\(N\\) ions<ul> <li>\\(J\\) specified levels each</li> </ul> </li> <li>\\(M\\) lasers</li> <li>\\(L\\) phonon modes</li> </ul> <p>Implemented with ConstructHamiltonian for the full Hamiltonian without any of the approximations used below.</p>"},{"location":"explanation/hamiltonian_construction/derivation/#simple-2-level-ion-system","title":"Simple 2-level Ion System","text":"<p>We'll start by deriving the Hamiltonian for a simple, 2-level system separated by energy \\(\\hbar\\omega_0\\), where \\(\\omega_0\\) is the transition frequency. When the ion is irradiated by a laser, its hydrogen-like Hamiltonian with electronic and motional degrees of freedom \\(H_{\\text{el}} + H_{\\text{mot}}\\), is perturbed by \\(H_{ED}\\), the dipole operator</p> \\[ \\begin{align}     H &amp;= H_{\\text{el}} + H_{\\text{mot}} + H_{ED} \\\\     &amp;= \\frac{\\hbar\\omega_0}{2}\\left(|1\\rangle\\langle1| - |0\\rangle\\langle 0|\\right) + \\hbar\\nu a^{\\dagger}a + H_{ED}     \\end{align} \\] <p>where \\(\\nu\\) is the ion's center-of-mass motion mode frequency in the harmonic potential.</p> <p>To first order</p> \\[ H_{ED} = -\\vec{d}\\cdot\\vec{E} = e \\vec{r}_e \\cdot E_0\\hat{\\epsilon}\\cos({\\vec{k}\\cdot\\vec{r} - \\omega t + \\phi}) \\] <ul> <li>\\(\\hat{\\epsilon}\\) is the laser's polarization</li> <li>\\(\\vec{r}\\) and \\(\\vec{r}_e\\) are the center of mass positions of the nucleus and electron, respectively</li> <li>\\(\\omega\\) and \\(\\phi\\) are the laser's frequency and initial phase, respectively.</li> </ul> <p>Because \\(\\vec{r}_e\\) has odd parity, the diagonal entries in the dipole operator cancel, thus we can write \\(\\vec{d}\\cdot\\hat{\\epsilon}\\) in terms of the Pauli raising and lower operators</p> \\[ \\begin{align}     \\sigma_+ &amp;= \\frac{1}{2} (\\sigma_x + i \\sigma_y) = |1\\rangle\\langle0| =     \\begin{pmatrix}     0 &amp; 1\\\\     0 &amp; 0     \\end{pmatrix} \\\\     \\sigma_- &amp;= \\frac{1}{2} (\\sigma_x - i \\sigma_y) = |0\\rangle\\langle1| =     \\begin{pmatrix}     0 &amp; 0\\\\     1 &amp; 0     \\end{pmatrix}     \\end{align} \\] <p>We'll follow the convention that the highest level in the number basis corresponds to the unit vector whose first entry is 1:</p> \\[ |1\\rangle = \\begin{pmatrix}     1\\\\     0 \\end{pmatrix}, \\quad |0\\rangle = \\begin{pmatrix}     0\\\\     1 \\end{pmatrix} \\] <p>Making these substitutions, expanding the cosine, and taking the Rabi frequency to be \\(\\Omega = \\frac{eE_0}{\\hbar} \\langle 1|\\vec{r}_e \\cdot \\hat{\\epsilon}_l | 0\\rangle\\), we arrive a</p> \\[ H_{ED} = \\frac{\\hbar\\Omega}{2}(\\sigma_+ + \\sigma_-)\\left[e^{i(\\vec{k}\\cdot\\vec{r}-\\omega t +\\phi)} + e^{-i(\\vec{k}\\cdot\\vec{r}-\\omega t +\\phi)}\\right] \\] <p>Note</p> <p>The computation of the matrix elements: \\(\\langle 1|\\vec{r}_e \\cdot \\vec{\\epsilon}_l | 0\\rangle\\), for dipole and quadropole transitions is described here.</p>"},{"location":"explanation/hamiltonian_construction/derivation/#interaction-picture-for-spin","title":"Interaction Picture for Spin","text":"<p>In principle, this Hamiltonian fully describes the motional and internal dynamics of the 2-level system. However, for computational purposes and for gaining greater intuition about the system, we boost into the frame rotating at the transition frequency \\(\\omega_0\\):</p> \\[ \\begin{align} H_0 &amp;= H_{\\mathrm{el}} = \\frac{\\hbar\\omega_0}{2}\\sigma_z, \\quad U = \\exp(-iH_0t/\\hbar), \\quad H_I = H_{ED} \\\\ H'_I &amp;= U^{\\dagger}H_I U \\\\ &amp;= \\frac{\\hbar\\Omega}{2} e^{i\\frac{\\omega_0t}{2}\\sigma_z}(\\sigma_+ + \\sigma_-)e^{-i\\frac{\\omega_0t}{2}\\sigma_z}[\\dots] \\\\ &amp;= \\frac{\\hbar\\Omega}{2}(e^{i\\omega_0t}\\sigma_+ + e^{-i\\omega_0t}\\sigma_-)\\left[e^{i(\\vec{k}\\cdot\\vec{r}-\\omega t +\\phi)} + e^{-i(\\vec{k}\\cdot\\vec{r}-\\omega t +\\phi)}\\right] \\end{align} \\] <p>Note</p> <p>The transform is equivalent to: \\(\\sigma_+ \\rightarrow e^{i\\omega_0 t}\\sigma_+\\) and \\(\\sigma_- \\rightarrow e^{-i\\omega_0 t}\\sigma_-\\).</p>"},{"location":"explanation/hamiltonian_construction/derivation/#motional-coupling","title":"Motional Coupling","text":"<p>Next, we include the effects of motional coupling by taking \\(\\vec{k}\\cdot\\vec{r} = \\eta(a^{\\dagger} + a )\\), where \\(a, a^{\\dagger}\\) are the harmonic oscillator ladder operators and \\(\\eta\\) is the Lamb-Dicke parameter</p> \\[     \\begin{align}     H'_I &amp;= \\frac{\\hbar\\Omega}{2}(e^{i\\omega_0t}\\sigma_+ + e^{-i\\omega_0t}\\sigma_-)\\left\\{e^{i[\\eta(a^{\\dagger}+a)-\\omega t +\\phi]} + e^{-i[\\eta(a^{\\dagger} + a)-\\omega t +\\phi}\\right\\}\\\\     &amp;= (\\dots) \\left[e^{i\\eta(a^{\\dagger} + a)}e^{-i(\\omega t - \\phi)} + e^{-i\\eta(a^{\\dagger} + a)}e^{i(\\omega t - \\phi)} \\right]\\\\     &amp;= \\frac{\\hbar\\Omega}{2} \\biggl[e^{i\\eta(a^{\\dagger} + a)}e^{-i[(\\omega-\\omega_0)t - \\phi]}\\sigma_+ + e^{-i\\eta(a^{\\dagger} + a)}e^{i[(\\omega+\\omega_0)t - \\phi]} \\sigma_+ + e^{i\\eta(a^{\\dagger} + a)}e^{-i[(\\omega+\\omega_0)t - \\phi]}\\sigma_- + e^{-i\\eta(a^{\\dagger} + a)}e^{i[(\\omega-\\omega_0)t - \\phi]} \\sigma_- \\biggr]     \\end{align} \\]"},{"location":"explanation/hamiltonian_construction/derivation/#rotating-wave-approximation-rwa","title":"Rotating Wave Approximation (RWA)","text":"<p>Under the rotating wave approximation (RWA), we neglect the fast oscillating terms, those with frequency \\(\\omega_0 + \\omega\\), and define the detuning from resonance \\(\\Delta = \\omega - \\omega_0\\)</p> \\[     H'_I = \\frac{\\hbar\\Omega}{2} \\biggl[e^{i\\eta(a^{\\dagger} + a)}e^{-i(\\Delta t - \\phi)}\\sigma_+ + e^{-i\\eta(a^{\\dagger} + a)}e^{i(\\Delta t - \\phi)} \\sigma_- \\biggr] \\]"},{"location":"explanation/hamiltonian_construction/derivation/#interaction-picture-for-phonons","title":"Interaction Picture for Phonons","text":"<p>At this point we apply one more transformation: boosting into the frame rotating at the ion's motional frequency \\(\\nu\\).</p> \\[     \\begin{align}     H''_I &amp;= \\frac{\\hbar\\Omega}{2} e^{i\\nu t a^{\\dagger}a}\\left[e^{i\\eta(a^{\\dagger} + a)}e^{-i(\\Delta t - \\phi)} + e^{-i\\eta(a^{\\dagger} + a)}e^{i(\\Delta t - \\phi)} \\right]e^{-i\\nu t a^{\\dagger}a}     \\end{align} \\] <p>Note</p> <p>The transform is equivalent to \\(e^{i\\eta(a^{\\dagger} + a)} \\rightarrow D(\\alpha) = \\exp\\left(\\alpha \\hat{a}^{\\dagger} - \\alpha^* \\hat{a}\\right)\\) where \\(\\alpha = i\\eta e^{i \\nu t}\\).</p> \\[     \\begin{align}     H''_I &amp;= \\frac{\\hbar\\Omega}{2} \\biggl[e^{-i(\\Delta t - \\phi)}\\sigma_+ D(\\alpha) + e^{i(\\Delta t - \\phi)}\\sigma_- D(-\\alpha)\\biggr]\\\\     &amp;= \\frac{\\hbar\\Omega}{2} \\biggl[e^{-i(\\Delta t - \\phi)}\\sigma_+ D(\\alpha)\\biggr] + H.C.     \\end{align} \\]"},{"location":"explanation/hamiltonian_construction/derivation/#additional-phonon-modes","title":"Additional Phonon Modes","text":"<p>We assumed motion in only one dimension, but we can easily generalize to \\(L\\) mode coupling</p> \\[     \\vec{k} \\cdot \\vec{r} = \\sum_l \\eta_l(\\hat{a}_l^{\\dagger} + \\hat{a}_l) \\] <p>Because \\(a^{\\dagger}_l, a_l\\) commute with \\(a^{\\dagger}_k,a_k\\) (\\(l\\neq k\\)), and \\(D(\\alpha)\\) commutes with all other terms in the Hamiltonian, we can simply write the motional term as the product of displacement operators:</p> <p></p> <p>Important</p> \\[     H''_I = \\frac{\\hbar\\Omega}{2}\\left[e^{-i(\\Delta t - \\phi)}\\sigma_+ \\prod_l^L D(\\alpha_l) \\right] + H.C. \\] <p>where the coherent state parameter picks up a mode index \\(\\alpha_l = i\\eta_l e^{i \\nu_l t}\\). We know that for a single ion, the \\(l\\) indices correspond to motion along \\(\\hat{e}_x\\), \\(\\hat{e}_y\\) and \\(\\hat{e}_z\\).</p>"},{"location":"explanation/hamiltonian_construction/derivation/#generalization","title":"Generalization","text":"<p>Let's now fully generalize the Single-ion Hamiltonian for:</p> <ul> <li>\\(N\\) ions<ul> <li>\\(J\\) considered electronic states each</li> </ul> </li> <li>\\(M\\) lasers</li> </ul>"},{"location":"explanation/hamiltonian_construction/derivation/#additional-lasers","title":"Additional Lasers","text":"<p>Introduce \\(M\\) laser fields irradiating the ion. Moving forward, \\(m\\) will represent the laser index, which marks all laser-specific parameters (\\(\\phi_m\\), \\(\\omega_m\\), \\(\\vec{k}_m\\), \\(\\hat{\\epsilon}_m\\), \\(E_{0,m}\\)). \\(H_{ED}\\) now becomes:</p> \\[     H_{ED} = -\\vec{d}\\cdot\\vec{E} = e \\vec{r}_e \\cdot \\sum_m E_{0,m} \\hat{\\epsilon}_m \\cos(\\vec{k}_m\\cdot\\vec{r} - \\omega_m t + \\phi_m) \\] <p>The Rabi frequency becomes \\(\\Omega_m = \\frac{eE_{0,m}}{\\hbar}\\langle1|\\vec{r}_e\\cdot\\hat{\\epsilon_m}|0\\rangle\\) as it gains laser index dependence.</p> \\[ H_{ED} = \\sum_m\\frac{\\hbar\\Omega_m}{2}(\\sigma_+ + \\sigma_-)\\left[e^{i\\left(\\vec{k}_m\\cdot\\vec{r}-\\omega_m t -\\phi_m\\right)} + e^{-i\\left(\\vec{k}_m\\cdot\\vec{r}-\\omega_m t -\\phi_m\\right)}\\right] \\] <p>Performing the same steps as before, we obtain:</p> <p>Important</p> \\[     H''_I = \\sum_m^M \\frac{\\hbar\\Omega_m}{2}\\left[e^{-i(\\Delta_m t - \\phi_m)}\\sigma_+ \\prod_l^L D(\\alpha_{ml}) \\right] + H.C. \\] <p>where \\(\\Delta_m = \\omega_m - \\omega_0\\) and \\(\\alpha_{ml} = i\\eta_{ml} e^{i \\nu_l t}\\). The Lamb-Dicke parameter gains a laser index as it's a function of the laser's alignment with the motional mode's axis.</p>"},{"location":"explanation/hamiltonian_construction/derivation/#additional-ions","title":"Additional Ions","text":"<p>We now consider \\(N\\) ions, each of which is still a 2-level system, irradiated by the superimposed classical field from \\(M\\)-lasers. Moving forward, \\(n\\) will be the ion index.</p> \\[     H_{ED} = \\sum_n-\\vec{d}_n\\cdot\\vec{E}_m(\\vec{r}_n, t) =\\sum_n e \\vec{r}_{e,n} \\cdot \\sum_m E_{0,m} \\hat{\\epsilon}_m \\cos(\\vec{k}_m\\cdot\\vec{r}_n - \\omega_m t + \\phi_m) \\] <p>Taking \\(\\Omega_{nm} = \\frac{eE_{0,m}}{\\hbar}\\langle1|\\vec{r}_{e,n}\\cdot\\hat{\\epsilon}_m|0\\rangle\\), we see the Rabi frequency, raising and lowering operators all pick up an ion index.</p> \\[ H_{ED} = \\sum_{n,m}\\frac{\\hbar\\Omega_{nm}}{2}\\left(\\sigma_+^{(n)} + \\sigma_-^{(n)}\\right)\\left[e^{i\\left(\\vec{k}_m\\cdot\\vec{r}_n-\\omega_m t +\\phi_m\\right)} + e^{-i\\left(\\vec{k}_m\\cdot\\vec{r}_n-\\omega_m t +\\phi_m\\right)}\\right] \\] <p>Performing the same steps as before, we obtain:</p> <p>Important</p> \\[     H''_I = \\sum_n^N \\sum_{m}^N \\frac{\\hbar\\Omega_{nm}}{2}\\left[e^{-i(\\Delta_{nm} t - \\phi_m)}\\sigma_+^{(n)} \\prod_l^L D(\\alpha_{nml}) \\right] + H.C. \\] <p>where \\(\\Delta_{nm} = \\omega_m - \\omega_{0,n}\\) and \\(\\alpha_{nml} = i\\eta_{nml} e^{i \\nu_l t}\\). The Lamb-Dicke parameter depends on the ion's mass.</p>"},{"location":"explanation/hamiltonian_construction/derivation/#additional-levels","title":"Additional Levels","text":"<p>Finally we consider ions where we include more than two levels in their Hilbert space. Immediately, we must modify \\(H_{\\mathrm{el}}\\) to reflect the eigen-energies associated with our \\(J_n\\) internal states (in the \\(n^{\\mathrm{th}}\\) ion)</p> \\[     H_{\\text{int}}^{(n)} =  \\hbar\\sum_{j_n}^{J_n}\\omega_{0 j_n}|j_n\\rangle\\langle j_n| \\] <p>\\(\\hbar\\omega_{0 j_n}\\) is the energy separation between the ground and \\(j_n^{\\mathrm{th}}\\) level. Thus, \\(\\hbar\\omega_{00} = 0\\). \\(H_{ED}\\) must also be modified to account for coupling between all level pairs; coupling is ultimately determined from their respective matrix elements.</p> <p>At this point, it becomes clear that the electronic ladder operators we've been using are now ambiguous: between which level pairs does it act? Thus, we introduce some notation: let \\(\\sigma_{+}^{(njk)} = |k_n\\rangle\\langle j_n|\\) be the raising operator for the \\(|j_n\\rangle \\leftrightarrow |k_n\\rangle\\) transition in the \\(n^{\\mathrm{th}}\\) ion, where we take \\(k_n\\) to be higher in energy than \\(j_n\\) (the corresponding lowering operator is simply the Hermitian conjugate). Thus, \\(H_{ED}\\) for any such level pairs in ion \\(n\\), addressed by laser \\(m\\), become:</p> \\[     H_{ED}^{(nmjk)} =     \\frac{\\hbar\\Omega_{nmjk}}{2}\\left(\\sigma_+^{(njk)} + \\sigma_-^{(njk)}\\right)\\left[e^{i(\\vec{k}_m\\cdot\\vec{r}_n-\\omega_m t -\\phi_m)}  + e^{-i(\\vec{k}_m\\cdot\\vec{r}_n-\\omega_m t -\\phi_m)}\\right] \\] <p>and the full perturbative term is now:</p> \\[     H_{ED} = \\sum_{n}\\sum_{m}\\sum_{j_n\\neq k_n}H_{ED}^{(nmjk)} \\] <p>for unique \\(j_n, k_n\\) pairs.</p> <p>Performing the same steps as before, we obtain:</p> <p></p> <p>Important</p> \\[ H''_I = \\sum_n^N \\sum_{m}^N \\sum_{j_n \\neq k_n}^{J_n} \\frac{\\hbar\\Omega_{nmjk}}{2}\\left[e^{-i(\\Delta_{nmjk} t - \\phi_m)}\\sigma_+^{(njk)} \\prod_l^L D(\\alpha_{nml}) \\right] + H.C. \\] <p>where \\(\\Delta_{nmjk} = \\omega_m - \\omega_{njk}\\) and \\(\\omega_{njk}\\) is the transition frequency for \\(|j_n\\rangle \\leftrightarrow |k_n\\rangle\\) in the \\(n^{\\mathrm{th}}\\) ion.</p>"},{"location":"explanation/hamiltonian_construction/matrix_elements/","title":"Matrix Elements","text":"<p>Goal</p> <p>Compute the multipole matrix elements with compute_matrix_element.</p> <p>Multipole matrix elements determine the coupling between transitions. The Rabi frequencies is defined as</p> \\[ \\Omega = \\begin{cases}     \\frac{eE_0}{\\hbar} \\langle 1|\\vec{r}_e \\cdot \\hat{\\epsilon}|0 \\rangle \\, \\text{for electric transitions} \\\\     \\frac{B_0}{\\hbar} \\langle 1|\\vec{\\mu} \\cdot \\hat{b}|0 \\rangle \\, \\text{for magnetic transitions} \\end{cases} \\] <p>In this section we'll describe how these \\(\\langle 1|\\vec{r}_e \\cdot \\hat{\\epsilon}|0 \\rangle, \\langle 1|\\vec{\\mu} \\cdot \\hat{b}|0 \\rangle\\) elements are computed. Currently, TrICal supports matrix element computation for:</p> <ul> <li>Electric dipole (E1)</li> <li>Magnetic dipole (M1)</li> <li>Electric quadrupole (E2)</li> </ul> <p>Let's consider a transition from level 0 to 1 in an ion with nuclear spin \\(I\\) and associated quantum numbers:</p> symbol definition \\(M_i\\) magnetization (a.k.a. \\(m_F\\)) \\(J_i\\) spin-orbital \\(F_i\\) total angular momentum \\(q = M_1 - M_0\\) change in magnetization for the transiton Electric Dipole TransitionsMagnetic Dipole TransitionsElectric Quadrupole Transitions <p>For dipole transitions, \\(q\\) can be \\(0, \\pm 1\\), each of which corresponds to a required polarization \\(\\hat{q}\\):</p> \\(q\\) \\(\\hat{q}\\) \\(\\sigma_{-}\\) -1 \\(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1\\\\ i\\\\ 0 \\end{pmatrix}\\) \\(\\pi\\) 0 \\(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0\\\\ 0\\\\ 1 \\end{pmatrix}\\) \\(\\sigma_{+}\\) 1 \\(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1\\\\ -i\\\\ 0 \\end{pmatrix}\\) <p>As a result, the matrix element will depend on the overlap between the laser's polarization (electric field direction) \\(\\hat{\\epsilon}\\) and the required \\(\\hat{q}\\).</p> <p>Important</p> \\[     \\langle 1|\\vec{r}_e \\cdot \\hat{\\epsilon}|0 \\rangle = \\frac{1}{\\omega_0 e}\\sqrt{\\frac{3\\pi\\epsilon_0\\hbar c^3 A_{10}}{\\omega_0 }} \\sqrt{(2F_1 + 1)(2F_0 + 1)}     \\begin{Bmatrix}         J_0 &amp; J_1 &amp; 1\\\\         F_1 &amp; F_0 &amp; I     \\end{Bmatrix} \\nonumber \\\\     \\sqrt{2J_1+1} \\hat{q}\\cdot\\hat{\\epsilon}\\begin{pmatrix}         F_1 &amp; 1 &amp; F_0\\\\         M_1 &amp; -q &amp; -M_0     \\end{pmatrix} \\] <p>where \\(\\{\\}\\) refers to the Wigner-6j symbol and \\(()\\) refers to the Wigner-3j symbol.</p> <p>For dipole transitions, \\(q\\) can be \\(0, \\pm 1\\), each of which corresponds to a required polarization \\(\\hat{q}\\):</p> \\(q\\) \\(\\hat{q}\\) \\(\\sigma_{-}\\) -1 \\(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1\\\\ i\\\\ 0 \\end{pmatrix}\\) \\(\\pi\\) 0 \\(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0\\\\ 0\\\\ 1 \\end{pmatrix}\\) \\(\\sigma_{+}\\) 1 \\(\\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1\\\\ -i\\\\ 0 \\end{pmatrix}\\) <p>As a result, the matrix element will depend on the overlap between the laser's magnetic field direction \\(\\hat{b} = \\hat{k} \\times \\hat{\\epsilon}\\) and the required \\(\\hat{q}\\).</p> <p>Important</p> \\[     \\langle 1|\\vec{\\mu} \\cdot \\hat{b}|0 \\rangle = \\sqrt{\\frac{3 \\hbar \\epsilon_0 c^5 A_{10}}{16 \\pi^3 \\omega_0^3}} \\sqrt{(2F_1 + 1)(2F_0 + 1)}     \\begin{Bmatrix}         J_0 &amp; J_1 &amp; 1\\\\         F_1 &amp; F_0 &amp; I     \\end{Bmatrix} \\nonumber \\\\     \\sqrt{2J_1+1} \\hat{q}\\cdot\\hat{b}\\begin{pmatrix}         F_1 &amp; 1 &amp; F_0\\\\         M_1 &amp; -q &amp; -M_0     \\end{pmatrix} \\] <p>where \\(\\{\\}\\) refers to the Wigner-6j symbol and \\(()\\) refers to the Wigner-3j symbol.</p> <p>For quadrupole transitions, the laser's unit wavevector \\(\\hat{k}\\) becomes relevant for coupling (in addition to its polarization). In particular, the coupling strength is now proportional to the overlap between \\(\\hat{k}\\) and \\(\\hat{Q}\\hat{\\epsilon}\\).</p> <p>\\(\\hat{Q}\\) is a matrix that depends on the value for \\(q\\), which can now be one of \\(0, \\pm 1, \\pm 2\\):</p> \\(q\\) \\(\\hat{Q}\\) -2 \\(\\frac{1}{\\sqrt{6}}\\begin{pmatrix} 1 &amp; i &amp; 0\\\\ i &amp; -1 &amp; 0\\\\ 0 &amp; 0 &amp; 0\\end{pmatrix}\\) -1 \\(\\frac{1}{\\sqrt{6}}\\begin{pmatrix} 0 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; i\\\\ 1 &amp; i &amp; 0\\end{pmatrix}\\) 0 \\(\\frac{1}{3}\\begin{pmatrix} -1 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 0\\\\ 0 &amp; 0 &amp; 2\\end{pmatrix}\\) 1 \\(\\frac{1}{\\sqrt{6}}\\begin{pmatrix} 0 &amp; 0 &amp; -1\\\\ 0 &amp; 0 &amp; i\\\\ -1 &amp; i &amp; 0\\end{pmatrix}\\) 2 \\(\\frac{1}{\\sqrt{6}}\\begin{pmatrix} 1 &amp; -i &amp; 0\\\\ -i &amp; -1 &amp; 0\\\\ 0 &amp; 0 &amp; 0\\end{pmatrix}\\) <p>Important</p> \\[     \\langle 1|\\vec{r}_e \\cdot \\hat{\\epsilon}|0 \\rangle = \\frac{1}{\\omega_0 e}\\sqrt{\\frac{15\\pi\\epsilon_0\\hbar c^3 A_{10}}{\\omega_0}} \\sqrt{(2F_1 + 1)(2F_0 + 1)}     \\begin{Bmatrix}         J_0 &amp; J_1 &amp; 2\\\\         F_1 &amp; F_0 &amp; I     \\end{Bmatrix} \\nonumber \\\\  \\sqrt{2J_1+1} \\hat{k}\\cdot\\hat{Q}\\hat{\\epsilon}\\begin{pmatrix}         F_1 &amp; 2 &amp; F_0\\\\         M_1 &amp; -q &amp; -M_0     \\end{pmatrix} \\]"},{"location":"explanation/hamiltonian_construction/zeeman/","title":"Zeeman Shifts","text":"<p>Goal</p> <p>Compute the Zeeman shift.</p> <p>In the presence of a magnetic field, an ion's levels will be shifted, leading to a loss of degeneracy in its various manifolds. For example, the \\(4S_{1/2}\\) manifold is two-fold degenerate because both \\(m_F = \\frac{1}{2}\\) and \\(m_F = -\\frac{1}{2}\\) have the same energy. However, when a magnetic field with magnitude \\(B\\) is applied, the degeneracy is broken: the \\(m_F = \\frac{1}{2}\\) level will be shifted up and the \\(m_F = -\\frac{1}{2}\\) will be shifted down.</p> <p>In the weak field regime, this Zeeman shift is given by</p> \\[     \\Delta_B = m_F g_F \\mu_B B \\] <p>where \\(\\mu_B\\) is the Bohr magneton (\\(\\approx 9.27 \\times 10^{-24}\\) J/T) and \\(g_F\\) is the total angular momentum F Lande g-factor. It can be written in terms of the spin-orbital angular momentum Lande g-factor, \\(g_J\\):</p> \\[     g_F = g_J \\frac{F(F+1) + J(J+1) - I(I+1)}{2F(F+1)} \\] <p>where F, J, and I are the total, spin-orbital, and nuclear angular momentum quantum numbers, respectively. Finally,</p> \\[     g_J = \\frac{3}{2} + \\frac{S(S+1) - L(L+1)}{2J(J+1)} \\] <p>where \\(S\\) is the spin angular momentum quantum number.</p>"},{"location":"get-started/acknowledgement/","title":"Acknowledgement","text":"<p>This package was inspired by the following packages:</p>"},{"location":"get-started/acknowledgement/#ionsimjl","title":"IonSim.jl","text":""},{"location":"get-started/installation/","title":"Installation","text":"<p>Clone the repository using the following command:</p> <pre><code>git clone https://github.com/OpenQuantumDesign/TrICal.git\n</code></pre> <p>Install with pip:</p> <pre><code>pip install .\n</code></pre> <p>TrICal has a dependency on oqd-compiler-infrastructure and oqd-core.</p>"},{"location":"get-started/outlook/","title":"Features in development","text":"<ul> <li> <code>oqd_trical.mechanical</code> uses atomic interface from <code>oqd-core</code>.</li> <li> <code>oqd_trical.mechanical</code> change autograd backend to jax.</li> <li> Compute Zeeman shifts based on magnetic field.</li> <li> Rule for Lamb-Dicke approximation.  </li> <li> Rule for rotating wave approximation.  </li> <li> Rule for moving into interaction picture for a rotating frame of reference.  </li> <li> Rule for performing adiabatic elimination.  </li> <li> Unit test for <code>oqd_trical</code> </li> <li> <code>ConstructHamiltonian</code> support for sequential within parallel protocol</li> <li> Sort out units  </li> </ul>"},{"location":"reference/interface/","title":"Interface","text":""},{"location":"reference/interface/#oqd_trical.light_matter.interface","title":"<code>oqd_trical.light_matter.interface</code>","text":""},{"location":"reference/interface/#oqd_trical.light_matter.interface.emulator","title":"<code>emulator</code>","text":""},{"location":"reference/interface/#oqd_trical.light_matter.interface.emulator.AtomicEmulatorCircuit","title":"<code>AtomicEmulatorCircuit</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a quantum information experiment represented in terms of atomic operations expressed in terms of their Hamiltonians.</p> <p>Attributes:</p> Name Type Description <code>frame</code> <code>Optional[Operator]</code> <p><code>Operator</code> that defines the rotating frame of reference.</p> <code>base</code> <code>Operator</code> <p>Free Hamiltonian.</p> <code>sequence</code> <code>List[AtomicEmulatorGate]</code> <p>List of gates to apply.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\emulator.py</code> <pre><code>class AtomicEmulatorCircuit(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a quantum information experiment represented in terms of atomic operations expressed in terms of their Hamiltonians.\n\n    Attributes:\n        frame (Optional[Operator]): [`Operator`][oqd_trical.light_matter.interface.operator.Operator] that defines the rotating frame of reference.\n        base (Operator): Free Hamiltonian.\n        sequence (List[AtomicEmulatorGate]): List of gates to apply.\n\n    \"\"\"\n\n    frame: Optional[OperatorSubTypes] = None\n    sequence: List[AtomicEmulatorGate]\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.emulator.AtomicEmulatorGate","title":"<code>AtomicEmulatorGate</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a gate represented in terms of atomic operations expressed in terms of their Hamiltonians.</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>Operator</code> <p>Hamiltonian to evolve by.</p> <code>duration</code> <code>float</code> <p>Time to evolve for.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\emulator.py</code> <pre><code>class AtomicEmulatorGate(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a gate represented in terms of atomic operations expressed in terms of their Hamiltonians.\n\n    Attributes:\n        hamiltonian (Operator): Hamiltonian to evolve by.\n        duration (float): Time to evolve for.\n    \"\"\"\n\n    hamiltonian: OperatorSubTypes\n    duration: float\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator","title":"<code>operator</code>","text":""},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.Coefficient","title":"<code>Coefficient</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a scalar coefficient for an operator.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class Coefficient(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a scalar coefficient for an operator.\n    \"\"\"\n\n    def __neg__(self):\n        return CoefficientMul(\n            coeff1=WaveCoefficient(amplitude=-1, frequency=0, phase=0),\n            coeff2=self,\n        )\n\n    def __pos__(self):\n        return self\n\n    def __add__(self, other):\n        return CoefficientAdd(coeff1=self, coeff2=other)\n\n    def __sub__(self, other):\n        return self + (-other)\n\n    def __mul__(self, other):\n        if isinstance(other, Coefficient):\n            return CoefficientMul(coeff1=self, coeff2=other)\n        else:\n            return other * self\n\n    def __rmul__(self, other):\n        return self * other\n\n    def __truediv__(self, other):\n        if isinstance(self, WaveCoefficient) and isinstance(other, WaveCoefficient):\n            return CoefficientMul(\n                coeff1=self,\n                coeff2=WaveCoefficient(\n                    amplitude=1 / other.amplitude,\n                    frequency=-other.frequency,\n                    phase=-other.phase,\n                ),\n            )\n        if isinstance(self, CoefficientAdd) and isinstance(other, WaveCoefficient):\n            return CoefficientAdd(\n                coeff1=self.coeff1 / other, coeff2=self.coeff2 / other\n            )\n        if isinstance(self, CoefficientMul) and isinstance(other, WaveCoefficient):\n            return CoefficientMul(coeff1=self.coeff1, coeff2=self.coeff2 / other)\n        else:\n            raise TypeError(\"Division only supported for WaveCoefficients denominator\")\n\n    def conj(self):\n        return Post(ConjugateCoefficient())(self)\n\n    pass\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.WaveCoefficient","title":"<code>WaveCoefficient</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Class representing a wave coefficient for an operator of the following form: $$ A e^{i(\\omega t + \\phi)}. $$</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class WaveCoefficient(Coefficient):\n    \"\"\"\n    Class representing a wave coefficient for an operator of the following form:\n    $$\n    A e^{i(\\\\omega t + \\\\phi)}.\n    $$\n    \"\"\"\n\n    amplitude: CastMathExpr\n    frequency: CastMathExpr\n    phase: CastMathExpr\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.CoefficientAdd","title":"<code>CoefficientAdd</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Class representing the addition of coefficients</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class CoefficientAdd(Coefficient):\n    \"\"\"\n    Class representing the addition of coefficients\n    \"\"\"\n\n    coeff1: CoefficientSubTypes\n    coeff2: CoefficientSubTypes\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.CoefficientMul","title":"<code>CoefficientMul</code>","text":"<p>               Bases: <code>Coefficient</code></p> <p>Class representing the multiplication of coefficients</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class CoefficientMul(Coefficient):\n    \"\"\"\n    Class representing the multiplication of coefficients\n    \"\"\"\n\n    coeff1: CoefficientSubTypes\n    coeff2: CoefficientSubTypes\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.Operator","title":"<code>Operator</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a quantum operator.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class Operator(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a quantum operator.\n    \"\"\"\n\n    def __neg__(self):\n        return OperatorScalarMul(\n            op=self, coeff=WaveCoefficient(amplitude=-1, frequency=0, phase=0)\n        )\n\n    def __pos__(self):\n        return self\n\n    def __add__(self, other):\n        return OperatorAdd(op1=self, op2=other)\n\n    def __sub__(self, other):\n        return OperatorAdd(\n            op1=self,\n            op2=OperatorScalarMul(\n                op=other, coeff=WaveCoefficient(amplitude=-1, frequency=0, phase=0)\n            ),\n        )\n\n    def __matmul__(self, other):\n        if isinstance(other, Coefficient):\n            raise TypeError(\n                \"Tried Kron product between Operator and Coefficient. \"\n                + \"Scalar multiplication of Coefficient and Operator should be bracketed when perfoming Kron product.\"\n            )\n        return OperatorKron(op1=self, op2=other)\n\n    def __mul__(self, other):\n        if isinstance(other, Operator):\n            return OperatorMul(op1=self, op2=other)\n        else:\n            return OperatorScalarMul(op=self, coeff=other)\n\n    def __rmul__(self, other):\n        return self * other\n\n    pass\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.OperatorLeaf","title":"<code>OperatorLeaf</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing a leaf operator</p> <p>Attributes:</p> Name Type Description <code>subsystem</code> <code>Annotated[str, AfterValidator(issubsystem)]</code> <p>Label for the subsystem the operator acts on.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class OperatorLeaf(Operator):\n    \"\"\"\n    Class representing a leaf operator\n\n    Attributes:\n        subsystem (Annotated[str, AfterValidator(issubsystem)]): Label for the subsystem the operator acts on.\n    \"\"\"\n\n    subsystem: Annotated[str, AfterValidator(issubsystem)]\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.KetBra","title":"<code>KetBra</code>","text":"<p>               Bases: <code>OperatorLeaf</code></p> <p>Class representing a transition operator: $$ |i \\rangle \\langle j| $$</p> <p>Attributes:</p> Name Type Description <code>ket</code> <code>int</code> <p>End state.</p> <code>bra</code> <code>int</code> <p>Start state.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class KetBra(OperatorLeaf):\n    \"\"\"\n    Class representing a transition operator:\n    $$\n    |i \\\\rangle \\\\langle j|\n    $$\n\n    Attributes:\n        ket (int): End state.\n        bra (int): Start state.\n\n    \"\"\"\n\n    ket: int\n    bra: int\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.Annihilation","title":"<code>Annihilation</code>","text":"<p>               Bases: <code>OperatorLeaf</code></p> <p>Class representing an annihilation operator: $$ \\hat{a} $$</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class Annihilation(OperatorLeaf):\n    \"\"\"\n    Class representing an annihilation operator:\n    $$\n    \\\\hat{a}\n    $$\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.Creation","title":"<code>Creation</code>","text":"<p>               Bases: <code>OperatorLeaf</code></p> <p>Class representing an annihilation operator: $$ \\hat{a}^{\\dagger} $$</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class Creation(OperatorLeaf):\n    \"\"\"\n    Class representing an annihilation operator:\n    $$\n    \\\\hat{a}^{\\\\dagger}\n    $$\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.Displacement","title":"<code>Displacement</code>","text":"<p>               Bases: <code>OperatorLeaf</code></p> <p>Class representing a displacement operator: $$ e^{\\alpha \\hat{a}^{\\dagger} - \\alpha^* \\hat{a}} $$</p> <p>Attributes:</p> Name Type Description <code>alpha</code> <code>Coefficient</code> <p>Displacement angle.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class Displacement(OperatorLeaf):\n    \"\"\"\n    Class representing a displacement operator:\n    $$\n    e^{\\\\alpha \\\\hat{a}^{\\\\dagger} - \\\\alpha^* \\\\hat{a}}\n    $$\n\n    Attributes:\n        alpha (Coefficient): Displacement angle.\n    \"\"\"\n\n    alpha: CoefficientSubTypes\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.Identity","title":"<code>Identity</code>","text":"<p>               Bases: <code>OperatorLeaf</code></p> <p>Class representing an identity operator: $$ \\hat{\\mathbb{I}} $$</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class Identity(OperatorLeaf):\n    \"\"\"\n    Class representing an identity operator:\n    $$\n    \\\\hat{\\\\mathbb{I}}\n    $$\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.OperatorAdd","title":"<code>OperatorAdd</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing the addtition of <code>Operators</code>.</p> <p>Attributes:</p> Name Type Description <code>op1</code> <code>Operator</code> <p>Left hand side <code>Operator</code></p> <code>op2</code> <code>Operator</code> <p>Right hand side <code>Operator</code></p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class OperatorAdd(Operator):\n    \"\"\"\n    Class representing the addtition of [`Operators`][oqd_trical.light_matter.interface.operator.Operator].\n\n    Attributes:\n        op1 (Operator): Left hand side [`Operator`][oqd_trical.light_matter.interface.operator.Operator]\n        op2 (Operator): Right hand side [`Operator`][oqd_trical.light_matter.interface.operator.Operator]\n    \"\"\"\n\n    op1: OperatorSubTypes\n    op2: OperatorSubTypes\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.OperatorMul","title":"<code>OperatorMul</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing the multiplication of <code>Operators</code>.</p> <p>Attributes:</p> Name Type Description <code>op1</code> <code>Operator</code> <p>Left hand side <code>Operator</code></p> <code>op2</code> <code>Operator</code> <p>Right hand side <code>Operator</code></p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class OperatorMul(Operator):\n    \"\"\"\n    Class representing the multiplication of [`Operators`][oqd_trical.light_matter.interface.operator.Operator].\n\n    Attributes:\n        op1 (Operator): Left hand side [`Operator`][oqd_trical.light_matter.interface.operator.Operator]\n        op2 (Operator): Right hand side [`Operator`][oqd_trical.light_matter.interface.operator.Operator]\n    \"\"\"\n\n    op1: OperatorSubTypes\n    op2: OperatorSubTypes\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.OperatorKron","title":"<code>OperatorKron</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing the tensor product of <code>Operators</code>.</p> <p>Attributes:</p> Name Type Description <code>op1</code> <code>Operator</code> <p>Left hand side <code>Operator</code></p> <code>op2</code> <code>Operator</code> <p>Right hand side <code>Operator</code></p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class OperatorKron(Operator):\n    \"\"\"\n    Class representing the tensor product of [`Operators`][oqd_trical.light_matter.interface.operator.Operator].\n\n    Attributes:\n        op1 (Operator): Left hand side [`Operator`][oqd_trical.light_matter.interface.operator.Operator]\n        op2 (Operator): Right hand side [`Operator`][oqd_trical.light_matter.interface.operator.Operator]\n    \"\"\"\n\n    op1: OperatorSubTypes\n    op2: OperatorSubTypes\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.OperatorScalarMul","title":"<code>OperatorScalarMul</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing the scalar multiplication of a <code>Coefficient</code> and an <code>Operator</code>.</p> <p>Attributes:</p> Name Type Description <code>op</code> <code>Operator</code> <p><code>Operator</code> to multiply.</p> <code>coeff</code> <code>Coefficient</code> <p><code>Coefficient</code> to multiply.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>class OperatorScalarMul(Operator):\n    \"\"\"\n    Class representing the scalar multiplication of a [`Coefficient`][oqd_trical.light_matter.interface.operator.Coefficient]\n    and an [`Operator`][oqd_trical.light_matter.interface.operator.Operator].\n\n    Attributes:\n        op (Operator): [`Operator`][oqd_trical.light_matter.interface.operator.Operator] to multiply.\n        coeff (Coefficient): [`Coefficient`][oqd_trical.light_matter.interface.operator.Coefficient] to multiply.\n    \"\"\"\n\n    op: OperatorSubTypes\n    coeff: CoefficientSubTypes\n</code></pre>"},{"location":"reference/interface/#oqd_trical.light_matter.interface.operator.ConstantCoefficient","title":"<code>ConstantCoefficient(value)</code>","text":"<p>Function to create a constant coefficient.</p> Source code in <code>src\\oqd_trical\\light_matter\\interface\\operator.py</code> <pre><code>def ConstantCoefficient(value):\n    \"\"\"\n    Function to create a constant coefficient.\n    \"\"\"\n    return WaveCoefficient(amplitude=value, frequency=0, phase=0)\n</code></pre>"},{"location":"reference/misc/","title":"Miscellaneous","text":""},{"location":"reference/misc/#oqd_trical.misc","title":"<code>oqd_trical.misc</code>","text":""},{"location":"reference/misc/#oqd_trical.misc.constants","title":"<code>constants</code>","text":"<p>Module containing relevant constants, in SI units, for TrICal</p>"},{"location":"reference/misc/#oqd_trical.misc.constants.c","title":"<code>c: float = 299792458.0</code>  <code>module-attribute</code>","text":"<p>Speed of light</p>"},{"location":"reference/misc/#oqd_trical.misc.constants.e","title":"<code>e: float = 1.602176634e-19</code>  <code>module-attribute</code>","text":"<p>Elementary charge</p>"},{"location":"reference/misc/#oqd_trical.misc.constants.hbar","title":"<code>hbar: float = 1.054571817e-34</code>  <code>module-attribute</code>","text":"<p>Reduced Planck constant</p>"},{"location":"reference/misc/#oqd_trical.misc.constants.k_e","title":"<code>k_e: float = 8987551792.3</code>  <code>module-attribute</code>","text":"<p>Coulomb constant</p>"},{"location":"reference/misc/#oqd_trical.misc.constants.epsilon_0","title":"<code>epsilon_0: float = 8.8541878188e-12</code>  <code>module-attribute</code>","text":"<p>Permittivity of free space</p>"},{"location":"reference/misc/#oqd_trical.misc.constants.m_u","title":"<code>m_u: float = 1.66053906892e-27</code>  <code>module-attribute</code>","text":"<p>Atomic mass unit</p>"},{"location":"reference/misc/#oqd_trical.misc.constants.natural_l","title":"<code>natural_l(m, q, omega)</code>","text":"<p>Calculates a natural length scale for a trapped ion system</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Mass of ion</p> required <code>q</code> <code>float</code> <p>Charge of ion</p> required <code>omega</code> <code>float</code> <p>Trapping strength</p> required <p>Returns:</p> Type Description <code>float</code> <p>Natural length scale</p> Source code in <code>src\\oqd_trical\\misc\\constants.py</code> <pre><code>def natural_l(m, q, omega):\n    \"\"\"\n    Calculates a natural length scale for a trapped ion system\n\n    Args:\n        m (float): Mass of ion\n        q (float): Charge of ion\n        omega (float): Trapping strength\n\n    Returns:\n        (float): Natural length scale\n    \"\"\"\n    return (2 * k_e * q**2 / (m * omega**2)) ** (1 / 3)\n</code></pre>"},{"location":"reference/misc/#oqd_trical.misc.constants.natural_V","title":"<code>natural_V(m, q, omega)</code>","text":"<p>Calculates a natural energy scale for a trapped ion system</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Mass of ion</p> required <code>q</code> <code>float</code> <p>Charge of ion</p> required <code>omega</code> <code>float</code> <p>Trapping strength</p> required <p>Returns:</p> Type Description <code>float</code> <p>Natural energy scale</p> Source code in <code>src\\oqd_trical\\misc\\constants.py</code> <pre><code>def natural_V(m, q, omega):\n    \"\"\"\n    Calculates a natural energy scale for a trapped ion system\n\n    Args:\n        m (float): Mass of ion\n        q (float): Charge of ion\n        omega (float): Trapping strength\n\n    Returns:\n        (float): Natural energy scale\n    \"\"\"\n    return k_e * q**2 / natural_l(m, q, omega)\n</code></pre>"},{"location":"reference/misc/#oqd_trical.misc.linalg","title":"<code>linalg</code>","text":"<p>Module containing relevant linear algebra functions for TrICal.</p>"},{"location":"reference/misc/#oqd_trical.misc.linalg.orthonormal_subset","title":"<code>orthonormal_subset(x, tol=0.001)</code>","text":"<p>Finds an approximate orthonormal subset of a set of vectors, after normalization.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray[float]</code> <p>Set of vectors of interest.</p> required <code>tol</code> <code>float</code> <p>Tolerance when classifying 2 vectors as orthonormal.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>Orthonormal subset of the set of vectors of interest, after normalization.</p> Source code in <code>src\\oqd_trical\\misc\\linalg.py</code> <pre><code>def orthonormal_subset(x, tol=1e-3):\n    \"\"\"\n    Finds an approximate orthonormal subset of a set of vectors, after normalization.\n\n    Args:\n        x (np.ndarray[float]): Set of vectors of interest.\n        tol (float): Tolerance when classifying 2 vectors as orthonormal.\n\n    Returns:\n        (np.ndarray[float]): Orthonormal subset of the set of vectors of interest, after normalization.\n    \"\"\"\n    nx = np.linalg.norm(x, axis=-1)\n    idcs = (-nx).argsort()\n    x = x[idcs]\n    nx = nx[idcs]\n    x = x / nx.reshape(-1, 1)\n\n    i = 0\n    while i &lt; len(x):\n        idcs = (\n            np.logical_not(\n                np.isclose(np.einsum(\"i,ni-&gt;n\", x[i], x[i + 1 :]), 0, atol=tol)\n            ).nonzero()[0]\n            + i\n            + 1\n        )\n        x = np.delete(x, idcs, axis=0)\n        i += 1\n    return x\n</code></pre>"},{"location":"reference/misc/#oqd_trical.misc.multispecies","title":"<code>multispecies</code>","text":"<p>Module containing useful functions relavent for multi-species systems.</p>"},{"location":"reference/misc/#oqd_trical.misc.multispecies.dc_trap_geometry","title":"<code>dc_trap_geometry(omega)</code>","text":"<p>Calculates the trap geometry of a trapped ion system.</p> <p>Parameters:</p> Name Type Description Default <code>omega</code> <code>ndarray[float]</code> <p>Trap strengths of primary species</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>Trap geometry factors of the system</p> Source code in <code>src\\oqd_trical\\misc\\multispecies.py</code> <pre><code>def dc_trap_geometry(omega):\n    \"\"\"\n    Calculates the trap geometry of a trapped ion system.\n\n    Args:\n        omega (np.ndarray[float]): Trap strengths of primary species\n\n    Returns:\n        (np.ndarray[float]): Trap geometry factors of the system\n    \"\"\"\n    gamma_diff = (omega[1] ** 2 - omega[0] ** 2) / omega[2] ** 2\n    gamma_x = (gamma_diff + 1) / 2\n    gamma_y = 1 - gamma_x\n    gamma = np.array([gamma_x, gamma_y, 1])\n    return gamma\n</code></pre>"},{"location":"reference/misc/#oqd_trical.misc.multispecies.ms_trap_strength","title":"<code>ms_trap_strength(m, m0, omega)</code>","text":"<p>Calculates the transverse trap frequencies of non-primary species.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray[float]</code> <p>Mass of ions</p> required <code>m0</code> <code>float</code> <p>Mass of primary species</p> required <code>omega</code> <code>ndarray[float]</code> <p>Trap strengths of primary species</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>Trap strengths of the ions</p> Source code in <code>src\\oqd_trical\\misc\\multispecies.py</code> <pre><code>def ms_trap_strength(m, m0, omega):\n    \"\"\"\n    Calculates the transverse trap frequencies of non-primary species.\n\n    Args:\n        m (np.ndarray[float]): Mass of ions\n        m0 (float): Mass of primary species\n        omega (np.ndarray[float]): Trap strengths of primary species\n\n    Returns:\n        (np.ndarray[float]): Trap strengths of the ions\n    \"\"\"\n    omega_dc = omega[2]\n\n    gamma = dc_trap_geometry(omega)[:2]\n    omega_rf = np.sqrt(omega[0] ** 2 + omega_dc**2 * gamma[0])\n\n    omega_axial = np.sqrt(m0 / m) * omega[2]\n    omega_trans = np.sqrt(\n        (m0 / m) ** 2 * omega_rf**2 - np.outer(gamma, (m0 / m)) * omega_dc**2\n    )\n\n    omegas = np.vstack((omega_trans, omega_axial))\n    return omegas\n</code></pre>"},{"location":"reference/misc/#oqd_trical.misc.optimize","title":"<code>optimize</code>","text":"<p>Module containing default optimization function generators for TrICal.</p>"},{"location":"reference/misc/#oqd_trical.misc.optimize.dflt_opt","title":"<code>dflt_opt(ti, **kwargs)</code>","text":"<p>Default optimization function generator for equilibrium_position method of TrappedIons class.</p> <p>Parameters:</p> Name Type Description Default <code>ti</code> <code>TrappedIons</code> <p>Trapped ion system of interest.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Default optimization function that finds the equilibrium position of the trapped ions system of interest via the minimization of the potential.</p> Source code in <code>src\\oqd_trical\\misc\\optimize.py</code> <pre><code>def dflt_opt(ti, **kwargs):\n    \"\"\"\n    Default optimization function generator for equilibrium_position method of TrappedIons class.\n\n    Args:\n        ti (TrappedIons): Trapped ion system of interest.\n\n    Returns:\n        (Callable): Default optimization function that finds the equilibrium position of the trapped ions system of interest via the minimization of the potential.\n    \"\"\"\n    opt_params = {\"method\": \"SLSQP\", \"options\": {\"maxiter\": 1000}, \"tol\": 1e-15}\n    opt_params.update(kwargs)\n\n    if ti.dim == 1:\n        x_guess = np.linspace(-(ti.N - 1) / 2, (ti.N - 1) / 2, ti.N)\n    else:\n        x_guess = np.append(\n            np.concatenate([np.zeros(ti.N)] * (ti.dim - 1)),\n            np.linspace(-(ti.N - 1) / 2, (ti.N - 1) / 2, ti.N),\n        )\n\n    def _dflt_opt(f):\n        res = opt.minimize(f, x_guess, **opt_params)\n        assert res.success, res.__str__()\n        return res.x\n\n    return _dflt_opt\n</code></pre>"},{"location":"reference/misc/#oqd_trical.misc.optimize.dflt_ls_opt","title":"<code>dflt_ls_opt(deg)</code>","text":"<p>Default optimization function generator for multivariate_polyfit function.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <code>ndarray[int]</code> <p>Degree of polynomial used in the fit.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Default optimization function that finds the best polynomial, of the specified degree, fit for the data .</p> Source code in <code>src\\oqd_trical\\misc\\optimize.py</code> <pre><code>def dflt_ls_opt(deg):\n    \"\"\"\n    Default optimization function generator for multivariate_polyfit function.\n\n    Args:\n        deg (np.ndarray[int]): Degree of polynomial used in the fit.\n\n    Returns:\n        (Callable): Default optimization function that finds the best polynomial, of the specified degree, fit for the data .\n    \"\"\"\n\n    def _dflt_ls_opt(a, b):\n        res = opt.lsq_linear(a, b)\n        assert res.success\n        return res.x\n\n    return _dflt_ls_opt\n</code></pre>"},{"location":"reference/misc/#oqd_trical.misc.polynomial","title":"<code>polynomial</code>","text":"<p>Module containing relevant functions regarding polynomials for TrIcal.</p>"},{"location":"reference/misc/#oqd_trical.misc.polynomial.multivariate_polyfit","title":"<code>multivariate_polyfit(x, vals, deg, l=1, opt=dflt_ls_opt)</code>","text":"<p>Fits a set of data with a multivariate polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray[float]</code> <p>Independent values.</p> required <code>vals</code> <code>ndarray[float]</code> <p>Dependent value.</p> required <code>deg</code> <code>ndarray[int]</code> <p>Degree of polynomial used in the fit.</p> required <code>l</code> <code>float</code> <p>Length scale used when fitting, defaults to 1.</p> <code>1</code> <code>opt</code> <code>Callable</code> <p>Generator of the appropriate optimization function for the fit.</p> <code>dflt_ls_opt</code> <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>Coefficients of the best fit multivariate polynomial, of the specified degree.</p> Source code in <code>src\\oqd_trical\\misc\\polynomial.py</code> <pre><code>def multivariate_polyfit(x, vals, deg, l=1, opt=dflt_ls_opt):  # noqa: E741\n    \"\"\"\n    Fits a set of data with a multivariate polynomial.\n\n    Args:\n        x (np.ndarray[float]): Independent values.\n        vals (np.ndarray[float]): Dependent value.\n        deg (np.ndarray[int]): Degree of polynomial used in the fit.\n        l (float): Length scale used when fitting, defaults to 1.\n        opt (Callable): Generator of the appropriate optimization function for the fit.\n\n    Returns:\n        (np.ndarray[float]): Coefficients of the best fit multivariate polynomial, of the specified degree.\n    \"\"\"\n    dim = len(deg)\n    shape = np.array(deg) + 1\n\n    a = {1: poly.polyvander, 2: poly.polyvander2d, 3: poly.polyvander3d}[dim](\n        *(x / l).transpose(), deg\n    )\n    b = vals\n    return opt(deg)(a, b).reshape(shape) / l ** np.indices(shape).sum(0)\n</code></pre>"},{"location":"reference/backend/dynamiqs/","title":"Dynamiqs","text":""},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs","title":"<code>oqd_trical.backend.dynamiqs</code>","text":""},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.DynamiqsBackend","title":"<code>DynamiqsBackend</code>","text":"<p>               Bases: <code>BackendBase</code></p> <p>Backend for running simulation of AtomicCircuit with Dynamiqs</p> <p>Attributes:</p> Name Type Description <code>save_intermediate</code> <code>bool</code> <p>Whether compiler saves the intermediate representation of the atomic circuit</p> <code>approx_pass</code> <code>PassBase</code> <p>Pass of approximations to apply to the system.</p> <code>solver</code> <code>Literal[SESolver, MESolver]</code> <p>Dynamiqs solver to use.</p> <code>solver_options</code> <code>Dict[str, Any]</code> <p>Dynamiqs solver options</p> <code>intermediate</code> <code>AtomicEmulatorCircuit</code> <p>Intermediate representation of the atomic circuit during compilation</p> Source code in <code>src\\oqd_trical\\backend\\dynamiqs\\base.py</code> <pre><code>class DynamiqsBackend(BackendBase):\n    \"\"\"Backend for running simulation of AtomicCircuit with Dynamiqs\n\n    Attributes:\n        save_intermediate (bool): Whether compiler saves the intermediate representation of the atomic circuit\n        approx_pass (PassBase): Pass of approximations to apply to the system.\n        solver (Literal[\"SESolver\",\"MESolver\"]): Dynamiqs solver to use.\n        solver_options (Dict[str,Any]): Dynamiqs solver options\n        intermediate (AtomicEmulatorCircuit): Intermediate representation of the atomic circuit during compilation\n    \"\"\"\n\n    def __init__(\n        self,\n        save_intermediate=True,\n        approx_pass=None,\n        solver=\"SESolver\",\n        solver_options={},\n    ):\n        super().__init__()\n\n        self.save_intermediate = save_intermediate\n        self.intermediate = None\n        self.approx_pass = approx_pass\n        self.solver = solver\n        self.solver_options = solver_options\n\n    def compile(self, circuit, fock_cutoff):\n        \"\"\"\n        Compiles a AtomicCircuit or AtomicEmulatorCircuit to a [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n\n        Args:\n            circuit (Union[AtomicCircuit,AtomicEmulatorCircuit]): circuit to be compiled.\n            fock_cutoff (int): Truncation for fock spaces.\n\n        Returns:\n            experiment (DynamiqsExperiment): Compiled [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n            hilbert_space (Dict[str, int]): Hilbert space of the system.\n        \"\"\"\n        assert isinstance(circuit, (AtomicCircuit, AtomicEmulatorCircuit))\n\n        if isinstance(circuit, AtomicCircuit):\n            conversion = Post(ConstructHamiltonian())\n            intermediate = conversion(circuit)\n        else:\n            intermediate = circuit\n\n        intermediate = canonicalize_emulator_circuit_factory()(intermediate)\n\n        if self.approx_pass:\n            intermediate = Chain(\n                self.approx_pass, canonicalize_emulator_circuit_factory()\n            )(intermediate)\n\n        get_hilbert_space = GetHilbertSpace()\n        analysis = Post(get_hilbert_space)\n        analysis(intermediate)\n\n        hilbert_space = get_hilbert_space.hilbert_space\n        _hilbert_space = hilbert_space.hilbert_space\n        for k in _hilbert_space.keys():\n            if k[0] == \"P\":\n                _hilbert_space[k] = set(range(fock_cutoff))\n        hilbert_space = HilbertSpace(hilbert_space=_hilbert_space)\n\n        relabeller = Post(RelabelStates(hilbert_space.get_relabel_rules()))\n        intermediate = relabeller(intermediate)\n\n        if self.save_intermediate:\n            self.intermediate = intermediate\n\n        compiler_p3 = Post(DynamiqsCodeGeneration(hilbert_space=hilbert_space))\n        experiment = compiler_p3(intermediate)\n\n        return experiment, hilbert_space\n\n    def run(self, experiment, hilbert_space, timestep, *, initial_state=None):\n        \"\"\"\n        Runs a [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n\n        Args:\n            experiment (DynamiqsExperiment): [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment] to be executed.\n            hilbert_space (Dict[str, int]): Hilbert space of the system.\n            timestep (float): Timestep between tracked states of the evolution.\n\n        Returns:\n            result (Dict[str,Any]): Result of execution of [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n        \"\"\"\n        vm = Pre(\n            DynamiqsVM(\n                hilbert_space=hilbert_space,\n                timestep=timestep,\n                solver=self.solver,\n                solver_options=self.solver_options,\n                initial_state=initial_state,\n            )\n        )\n\n        vm(experiment)\n\n        return vm.children[0].result\n</code></pre>"},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.DynamiqsBackend.compile","title":"<code>compile(circuit, fock_cutoff)</code>","text":"<p>Compiles a AtomicCircuit or AtomicEmulatorCircuit to a <code>DynamiqsExperiment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Union[AtomicCircuit, AtomicEmulatorCircuit]</code> <p>circuit to be compiled.</p> required <code>fock_cutoff</code> <code>int</code> <p>Truncation for fock spaces.</p> required <p>Returns:</p> Name Type Description <code>experiment</code> <code>DynamiqsExperiment</code> <p>Compiled <code>DynamiqsExperiment</code>.</p> <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> Source code in <code>src\\oqd_trical\\backend\\dynamiqs\\base.py</code> <pre><code>def compile(self, circuit, fock_cutoff):\n    \"\"\"\n    Compiles a AtomicCircuit or AtomicEmulatorCircuit to a [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n\n    Args:\n        circuit (Union[AtomicCircuit,AtomicEmulatorCircuit]): circuit to be compiled.\n        fock_cutoff (int): Truncation for fock spaces.\n\n    Returns:\n        experiment (DynamiqsExperiment): Compiled [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n    \"\"\"\n    assert isinstance(circuit, (AtomicCircuit, AtomicEmulatorCircuit))\n\n    if isinstance(circuit, AtomicCircuit):\n        conversion = Post(ConstructHamiltonian())\n        intermediate = conversion(circuit)\n    else:\n        intermediate = circuit\n\n    intermediate = canonicalize_emulator_circuit_factory()(intermediate)\n\n    if self.approx_pass:\n        intermediate = Chain(\n            self.approx_pass, canonicalize_emulator_circuit_factory()\n        )(intermediate)\n\n    get_hilbert_space = GetHilbertSpace()\n    analysis = Post(get_hilbert_space)\n    analysis(intermediate)\n\n    hilbert_space = get_hilbert_space.hilbert_space\n    _hilbert_space = hilbert_space.hilbert_space\n    for k in _hilbert_space.keys():\n        if k[0] == \"P\":\n            _hilbert_space[k] = set(range(fock_cutoff))\n    hilbert_space = HilbertSpace(hilbert_space=_hilbert_space)\n\n    relabeller = Post(RelabelStates(hilbert_space.get_relabel_rules()))\n    intermediate = relabeller(intermediate)\n\n    if self.save_intermediate:\n        self.intermediate = intermediate\n\n    compiler_p3 = Post(DynamiqsCodeGeneration(hilbert_space=hilbert_space))\n    experiment = compiler_p3(intermediate)\n\n    return experiment, hilbert_space\n</code></pre>"},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.DynamiqsBackend.run","title":"<code>run(experiment, hilbert_space, timestep, *, initial_state=None)</code>","text":"<p>Runs a <code>DynamiqsExperiment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>experiment</code> <code>DynamiqsExperiment</code> <p><code>DynamiqsExperiment</code> to be executed.</p> required <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> required <code>timestep</code> <code>float</code> <p>Timestep between tracked states of the evolution.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Dict[str, Any]</code> <p>Result of execution of <code>DynamiqsExperiment</code>.</p> Source code in <code>src\\oqd_trical\\backend\\dynamiqs\\base.py</code> <pre><code>def run(self, experiment, hilbert_space, timestep, *, initial_state=None):\n    \"\"\"\n    Runs a [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n\n    Args:\n        experiment (DynamiqsExperiment): [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment] to be executed.\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n        timestep (float): Timestep between tracked states of the evolution.\n\n    Returns:\n        result (Dict[str,Any]): Result of execution of [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n    \"\"\"\n    vm = Pre(\n        DynamiqsVM(\n            hilbert_space=hilbert_space,\n            timestep=timestep,\n            solver=self.solver,\n            solver_options=self.solver_options,\n            initial_state=initial_state,\n        )\n    )\n\n    vm(experiment)\n\n    return vm.children[0].result\n</code></pre>"},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.DynamiqsCodeGeneration","title":"<code>DynamiqsCodeGeneration</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>Rule that converts an <code>AtomicEmulatorCircuit</code> to a <code>DynamiqsExperiment</code></p> <p>Attributes:</p> Name Type Description <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> Source code in <code>src\\oqd_trical\\backend\\dynamiqs\\codegen.py</code> <pre><code>class DynamiqsCodeGeneration(ConversionRule):\n    \"\"\"\n    Rule that converts an [`AtomicEmulatorCircuit`][oqd_trical.light_matter.interface.emulator.AtomicEmulatorCircuit]\n    to a [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment]\n\n    Attributes:\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n    \"\"\"\n\n    def __init__(self, hilbert_space: HilbertSpace):\n        super().__init__()\n\n        self.hilbert_space = hilbert_space\n\n    def map_AtomicEmulatorCircuit(self, model, operands):\n        return DynamiqsExperiment(\n            frame=None\n            if (\n                isinstance(operands[\"frame\"], PrunedOperator)\n                or operands[\"frame\"] is None\n            )\n            else dq.timecallable(operands[\"frame\"]),\n            sequence=operands[\"sequence\"],\n        )\n\n    def map_AtomicEmulatorGate(self, model, operands):\n        if isinstance(operands[\"hamiltonian\"], PrunedOperator):\n            return DynamiqsGate(hamiltonian=None, duration=operands[\"duration\"])\n\n        return DynamiqsGate(\n            hamiltonian=dq.timecallable(operands[\"hamiltonian\"]),\n            duration=operands[\"duration\"],\n        )\n\n    def map_Identity(self, model, operands):\n        op = dq.eye(self.hilbert_space.size[model.subsystem])\n        return lambda t: op\n\n    def map_KetBra(self, model, operands):\n        ket = dq.basis(self.hilbert_space.size[model.subsystem], model.ket)\n        bra = dq.basis(self.hilbert_space.size[model.subsystem], model.bra).dag()\n        op = ket @ bra\n\n        if not isinstance(op, dq.QArray):\n            op = dq.asqarray(op)\n        return lambda t: op\n\n    def map_Annihilation(self, model, operands):\n        op = dq.destroy(self.hilbert_space.size[model.subsystem])\n        return lambda t: op\n\n    def map_Creation(self, model, operands):\n        op = dq.create(self.hilbert_space.size[model.subsystem])\n        return lambda t: op\n\n    def map_Displacement(self, model, operands):\n        return lambda t: dq.displace(\n            self.hilbert_space.size[model.subsystem], operands[\"alpha\"](t)\n        )\n\n    def map_OperatorMul(self, model, operands):\n        return lambda t: operands[\"op1\"](t) @ operands[\"op2\"](t)\n\n    def map_OperatorKron(self, model, operands):\n        return lambda t: dq.tensor(operands[\"op1\"](t), operands[\"op2\"](t))\n\n    def map_OperatorAdd(self, model, operands):\n        return lambda t: operands[\"op1\"](t) + operands[\"op2\"](t)\n\n    def map_OperatorScalarMul(self, model, operands):\n        return lambda t: operands[\"coeff\"](t) * operands[\"op\"](t)\n\n    def map_WaveCoefficient(self, model, operands):\n        return lambda t: operands[\"amplitude\"](t) * jnp.exp(\n            1j * (operands[\"frequency\"](t) * t + operands[\"phase\"](t))\n        )\n\n    def map_CoefficientAdd(self, model, operands):\n        return lambda t: operands[\"coeff1\"](t) + operands[\"coeff2\"](t)\n\n    def map_CoefficientMul(self, model, operands):\n        return lambda t: operands[\"coeff1\"](t) * operands[\"coeff2\"](t)\n\n    def map_MathNum(self, model, operands):\n        return lambda t: model.value\n\n    def map_MathImag(self, model, operands):\n        return lambda t: 1j\n\n    def map_MathVar(self, model, operands):\n        if model.name == \"t\":\n            return lambda t: t\n\n        raise ValueError(\n            f\"Unsupported variable {model.name}, only variable t is supported\"\n        )\n\n    def map_MathFunc(self, model, operands):\n        if getattr(math, model.func, None):\n            return lambda t: getattr(jnp, model.func)(operands[\"expr\"](t))\n\n        if model.func == \"heaviside\":\n            return lambda t: jnp.heaviside(operands[\"expr\"](t), 1)\n\n        if model.func == \"conj\":\n            return lambda t: jnp.conj(operands[\"expr\"](t))\n\n        raise ValueError(f\"Unsupported function {model.func}\")\n\n    def map_MathAdd(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) + operands[\"expr2\"](t)\n\n    def map_MathSub(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) - operands[\"expr2\"](t)\n\n    def map_MathMul(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) * operands[\"expr2\"](t)\n\n    def map_MathDiv(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) / operands[\"expr2\"](t)\n\n    def map_MathPow(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) ** operands[\"expr2\"](t)\n</code></pre>"},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.DynamiqsVM","title":"<code>DynamiqsVM</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Rule that executes a <code>DynamiqsExperiment</code>.</p> <p>Attributes:</p> Name Type Description <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> <code>timestep</code> <code>float</code> <p>Timestep between tracked states of the evolution.</p> <code>solver</code> <code>Literal[SESolver, MESolver]</code> <p>Dynamiqs solver to use.</p> <code>solver_options</code> <code>Dict[str, Any]</code> <p>Dynamiqs solver options</p> Source code in <code>src\\oqd_trical\\backend\\dynamiqs\\vm.py</code> <pre><code>class DynamiqsVM(RewriteRule):\n    \"\"\"\n    Rule that executes a [`DynamiqsExperiment`][oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment].\n\n    Attributes:\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n        timestep (float): Timestep between tracked states of the evolution.\n        solver (Literal[\"SESolver\",\"MESolver\"]): Dynamiqs solver to use.\n        solver_options (Dict[str,Any]): Dynamiqs solver options\n    \"\"\"\n\n    def __init__(\n        self,\n        hilbert_space,\n        timestep,\n        *,\n        initial_state=None,\n        solver=\"SESolver\",\n        solver_options={},\n    ):\n        self.hilbert_space = hilbert_space\n        self.timestep = timestep\n\n        if initial_state:\n            if initial_state.dims != tuple(self.hilbert_space.size.values()):\n                raise ValueError(\"Initial state incompatible with Hilbert space\")\n            self.current_state = initial_state\n        else:\n            self.current_state = dq.tensor(\n                *[\n                    dq.basis(self.hilbert_space.size[k], 0)\n                    for k in self.hilbert_space.size.keys()\n                ]\n            )\n\n        self.states = [self.current_state]\n        self.tspan = [0.0]\n\n        self.solver = {\n            \"SESolver\": sesolve,\n            \"MESolver\": mesolve,\n        }[solver]\n        self.solver_options = solver_options\n\n    @property\n    def result(self):\n        return dict(\n            final_state=self.current_state,\n            states=self.states,\n            tspan=self.tspan,\n            frame=self.frame,\n            hilbert_space=self.hilbert_space,\n        )\n\n    def map_DynamiqsExperiment(self, model):\n        self.frame = model.frame\n\n    def map_DynamiqsGate(self, model):\n        tspan = jnp.arange(0, model.duration, self.timestep)\n\n        if tspan[-1] != model.duration:\n            tspan = jnp.append(tspan, model.duration)\n\n        tspan = tspan + self.tspan[-1]\n\n        empty_hamiltonian = model.hamiltonian is None\n\n        if empty_hamiltonian:\n            self.tspan.extend(list(tspan[1:] + self.tspan[-1]))\n            self.states.extend([self.current_state] * (len(tspan) - 1))\n            return\n\n        res = self.solver(\n            model.hamiltonian,\n            self.current_state,\n            tspan,\n            solver=self.solver_options[\"solver\"]\n            if \"solver\" in self.solver_options.keys()\n            else dq.solver.Tsit5(),\n        )\n\n        self.current_state = res.final_state\n\n        self.tspan.extend(list(tspan[1:]))\n        self.states.extend(list(res.states[1:]))\n</code></pre>"},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.interface","title":"<code>interface</code>","text":""},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.interface.DynamiqsExperiment","title":"<code>DynamiqsExperiment</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a Dynamiqs experiment represented in terms of atomic operations expressed in terms of their Hamiltonians.</p> <p>Attributes:</p> Name Type Description <code>base</code> <code>Operator</code> <p>Free Hamiltonian.</p> <code>sequence</code> <code>List[AtomicEmulatorGate]</code> <p>List of gates to apply.</p> Source code in <code>src\\oqd_trical\\backend\\dynamiqs\\interface.py</code> <pre><code>class DynamiqsExperiment(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a Dynamiqs experiment represented in terms of atomic operations expressed in terms of their Hamiltonians.\n\n    Attributes:\n        base (Operator): Free Hamiltonian.\n        sequence (List[AtomicEmulatorGate]): List of gates to apply.\n\n    \"\"\"\n\n    model_config = ConfigDict(validate_assignments=True, arbitrary_types_allowed=True)\n\n    frame: Optional[dq.TimeQArray]\n    sequence: List[DynamiqsGate]\n</code></pre>"},{"location":"reference/backend/dynamiqs/#oqd_trical.backend.dynamiqs.interface.DynamiqsGate","title":"<code>DynamiqsGate</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a Dynamiqs gate represented in terms of atomic operations expressed in terms of their Hamiltonians.</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>Operator</code> <p>Hamiltonian to evolve by.</p> <code>duration</code> <code>float</code> <p>Time to evolve for.</p> Source code in <code>src\\oqd_trical\\backend\\dynamiqs\\interface.py</code> <pre><code>class DynamiqsGate(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a Dynamiqs gate represented in terms of atomic operations expressed in terms of their Hamiltonians.\n\n    Attributes:\n        hamiltonian (Operator): Hamiltonian to evolve by.\n        duration (float): Time to evolve for.\n    \"\"\"\n\n    model_config = ConfigDict(validate_assignments=True, arbitrary_types_allowed=True)\n\n    hamiltonian: Optional[dq.TimeQArray]\n    duration: float\n</code></pre>"},{"location":"reference/backend/qutip/","title":"QuTiP","text":""},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip","title":"<code>oqd_trical.backend.qutip</code>","text":""},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.QutipBackend","title":"<code>QutipBackend</code>","text":"<p>               Bases: <code>BackendBase</code></p> <p>Backend for running simulation of AtomicCircuit with QuTiP</p> <p>Attributes:</p> Name Type Description <code>save_intermediate</code> <code>bool</code> <p>Whether compiler saves the intermediate representation of the atomic circuit</p> <code>approx_pass</code> <code>PassBase</code> <p>Pass of approximations to apply to the system.</p> <code>solver</code> <code>Literal[SESolver, MESolver]</code> <p>QuTiP solver to use.</p> <code>solver_options</code> <code>Dict[str, Any]</code> <p>Qutip solver options</p> <code>intermediate</code> <code>AtomicEmulatorCircuit</code> <p>Intermediate representation of the atomic circuit during compilation</p> Source code in <code>src\\oqd_trical\\backend\\qutip\\base.py</code> <pre><code>class QutipBackend(BackendBase):\n    \"\"\"Backend for running simulation of AtomicCircuit with QuTiP\n\n    Attributes:\n        save_intermediate (bool): Whether compiler saves the intermediate representation of the atomic circuit\n        approx_pass (PassBase): Pass of approximations to apply to the system.\n        solver (Literal[\"SESolver\",\"MESolver\"]): QuTiP solver to use.\n        solver_options (Dict[str,Any]): Qutip solver options\n        intermediate (AtomicEmulatorCircuit): Intermediate representation of the atomic circuit during compilation\n    \"\"\"\n\n    def __init__(\n        self,\n        save_intermediate=True,\n        approx_pass=None,\n        solver=\"SESolver\",\n        solver_options={\"progress_bar\": True},\n    ):\n        super().__init__()\n\n        self.save_intermediate = save_intermediate\n        self.intermediate = None\n        self.approx_pass = approx_pass\n        self.solver = solver\n        self.solver_options = solver_options\n\n    def compile(self, circuit, fock_cutoff):\n        \"\"\"\n        Compiles a AtomicCircuit or AtomicEmulatorCircuit to a [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n\n        Args:\n            circuit (Union[AtomicCircuit,AtomicEmulatorCircuit]): circuit to be compiled.\n            fock_cutoff (int): Truncation for fock spaces.\n\n        Returns:\n            experiment (QutipExperiment): Compiled [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n            hilbert_space (Dict[str, int]): Hilbert space of the system.\n        \"\"\"\n        assert isinstance(circuit, (AtomicCircuit, AtomicEmulatorCircuit))\n\n        if isinstance(circuit, AtomicCircuit):\n            conversion = Post(ConstructHamiltonian())\n            intermediate = conversion(circuit)\n        else:\n            intermediate = circuit\n\n        intermediate = canonicalize_emulator_circuit_factory()(intermediate)\n\n        if self.approx_pass:\n            intermediate = Chain(\n                self.approx_pass, canonicalize_emulator_circuit_factory()\n            )(intermediate)\n\n        get_hilbert_space = GetHilbertSpace()\n        analysis = Post(get_hilbert_space)\n        analysis(intermediate)\n\n        hilbert_space = get_hilbert_space.hilbert_space\n        _hilbert_space = hilbert_space.hilbert_space\n        for k in _hilbert_space.keys():\n            if k[0] == \"P\":\n                _hilbert_space[k] = set(range(fock_cutoff))\n        hilbert_space = HilbertSpace(hilbert_space=_hilbert_space)\n\n        relabeller = Post(RelabelStates(hilbert_space.get_relabel_rules()))\n        intermediate = relabeller(intermediate)\n\n        if self.save_intermediate:\n            self.intermediate = intermediate\n\n        compiler_p3 = Post(QutipCodeGeneration(hilbert_space=hilbert_space))\n        experiment = compiler_p3(intermediate)\n\n        return experiment, hilbert_space\n\n    def run(self, experiment, hilbert_space, timestep, *, initial_state=None):\n        \"\"\"\n        Runs a [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n\n        Args:\n            experiment (QutipExperiment): [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment] to be executed.\n            hilbert_space (Dict[str, int]): Hilbert space of the system.\n            timestep (float): Timestep between tracked states of the evolution.\n\n        Returns:\n            result (Dict[str,Any]): Result of execution of [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n        \"\"\"\n        vm = Pre(\n            QutipVM(\n                hilbert_space=hilbert_space,\n                timestep=timestep,\n                solver=self.solver,\n                solver_options=self.solver_options,\n                initial_state=initial_state,\n            )\n        )\n\n        vm(experiment)\n\n        return vm.children[0].result\n</code></pre>"},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.QutipBackend.compile","title":"<code>compile(circuit, fock_cutoff)</code>","text":"<p>Compiles a AtomicCircuit or AtomicEmulatorCircuit to a <code>QutipExperiment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Union[AtomicCircuit, AtomicEmulatorCircuit]</code> <p>circuit to be compiled.</p> required <code>fock_cutoff</code> <code>int</code> <p>Truncation for fock spaces.</p> required <p>Returns:</p> Name Type Description <code>experiment</code> <code>QutipExperiment</code> <p>Compiled <code>QutipExperiment</code>.</p> <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> Source code in <code>src\\oqd_trical\\backend\\qutip\\base.py</code> <pre><code>def compile(self, circuit, fock_cutoff):\n    \"\"\"\n    Compiles a AtomicCircuit or AtomicEmulatorCircuit to a [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n\n    Args:\n        circuit (Union[AtomicCircuit,AtomicEmulatorCircuit]): circuit to be compiled.\n        fock_cutoff (int): Truncation for fock spaces.\n\n    Returns:\n        experiment (QutipExperiment): Compiled [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n    \"\"\"\n    assert isinstance(circuit, (AtomicCircuit, AtomicEmulatorCircuit))\n\n    if isinstance(circuit, AtomicCircuit):\n        conversion = Post(ConstructHamiltonian())\n        intermediate = conversion(circuit)\n    else:\n        intermediate = circuit\n\n    intermediate = canonicalize_emulator_circuit_factory()(intermediate)\n\n    if self.approx_pass:\n        intermediate = Chain(\n            self.approx_pass, canonicalize_emulator_circuit_factory()\n        )(intermediate)\n\n    get_hilbert_space = GetHilbertSpace()\n    analysis = Post(get_hilbert_space)\n    analysis(intermediate)\n\n    hilbert_space = get_hilbert_space.hilbert_space\n    _hilbert_space = hilbert_space.hilbert_space\n    for k in _hilbert_space.keys():\n        if k[0] == \"P\":\n            _hilbert_space[k] = set(range(fock_cutoff))\n    hilbert_space = HilbertSpace(hilbert_space=_hilbert_space)\n\n    relabeller = Post(RelabelStates(hilbert_space.get_relabel_rules()))\n    intermediate = relabeller(intermediate)\n\n    if self.save_intermediate:\n        self.intermediate = intermediate\n\n    compiler_p3 = Post(QutipCodeGeneration(hilbert_space=hilbert_space))\n    experiment = compiler_p3(intermediate)\n\n    return experiment, hilbert_space\n</code></pre>"},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.QutipBackend.run","title":"<code>run(experiment, hilbert_space, timestep, *, initial_state=None)</code>","text":"<p>Runs a <code>QutipExperiment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>experiment</code> <code>QutipExperiment</code> <p><code>QutipExperiment</code> to be executed.</p> required <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> required <code>timestep</code> <code>float</code> <p>Timestep between tracked states of the evolution.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Dict[str, Any]</code> <p>Result of execution of <code>QutipExperiment</code>.</p> Source code in <code>src\\oqd_trical\\backend\\qutip\\base.py</code> <pre><code>def run(self, experiment, hilbert_space, timestep, *, initial_state=None):\n    \"\"\"\n    Runs a [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n\n    Args:\n        experiment (QutipExperiment): [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment] to be executed.\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n        timestep (float): Timestep between tracked states of the evolution.\n\n    Returns:\n        result (Dict[str,Any]): Result of execution of [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n    \"\"\"\n    vm = Pre(\n        QutipVM(\n            hilbert_space=hilbert_space,\n            timestep=timestep,\n            solver=self.solver,\n            solver_options=self.solver_options,\n            initial_state=initial_state,\n        )\n    )\n\n    vm(experiment)\n\n    return vm.children[0].result\n</code></pre>"},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.QutipCodeGeneration","title":"<code>QutipCodeGeneration</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>Rule that converts an <code>AtomicEmulatorCircuit</code> to a <code>QutipExperiment</code></p> <p>Attributes:</p> Name Type Description <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> Source code in <code>src\\oqd_trical\\backend\\qutip\\codegen.py</code> <pre><code>class QutipCodeGeneration(ConversionRule):\n    \"\"\"\n    Rule that converts an [`AtomicEmulatorCircuit`][oqd_trical.light_matter.interface.emulator.AtomicEmulatorCircuit]\n    to a [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment]\n\n    Attributes:\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n    \"\"\"\n\n    def __init__(self, hilbert_space: HilbertSpace):\n        super().__init__()\n\n        self.hilbert_space = hilbert_space\n\n    def map_AtomicEmulatorCircuit(self, model, operands):\n        return QutipExperiment(\n            frame=None\n            if (\n                isinstance(operands[\"frame\"], PrunedOperator)\n                or operands[\"frame\"] is None\n            )\n            else operands[\"frame\"],\n            sequence=operands[\"sequence\"],\n        )\n\n    def map_AtomicEmulatorGate(self, model, operands):\n        if isinstance(operands[\"hamiltonian\"], PrunedOperator):\n            return QutipGate(hamiltonian=None, duration=operands[\"duration\"])\n\n        return QutipGate(\n            hamiltonian=operands[\"hamiltonian\"], duration=operands[\"duration\"]\n        )\n\n    def map_Identity(self, model, operands):\n        op = qt.identity(self.hilbert_space.size[model.subsystem])\n        return qt.QobjEvo(op)\n\n    def map_KetBra(self, model, operands):\n        ket = qt.basis(self.hilbert_space.size[model.subsystem], model.ket)\n        bra = qt.basis(self.hilbert_space.size[model.subsystem], model.bra).dag()\n        op = ket * bra\n\n        if not isinstance(op, qt.Qobj):\n            op = qt.Qobj(op)\n        return qt.QobjEvo(op)\n\n    def map_Annihilation(self, model, operands):\n        op = qt.destroy(self.hilbert_space.size[model.subsystem])\n        return qt.QobjEvo(op)\n\n    def map_Creation(self, model, operands):\n        op = qt.create(self.hilbert_space.size[model.subsystem])\n        return qt.QobjEvo(op)\n\n    def map_Displacement(self, model, operands):\n        return qt.QobjEvo(\n            lambda t: qt.displace(\n                self.hilbert_space.size[model.subsystem], operands[\"alpha\"](t)\n            )\n        )\n\n    def map_OperatorMul(self, model, operands):\n        return operands[\"op1\"] * operands[\"op2\"]\n\n    def map_OperatorKron(self, model, operands):\n        return qt.tensor(operands[\"op1\"], operands[\"op2\"])\n\n    def map_OperatorAdd(self, model, operands):\n        return operands[\"op1\"] + operands[\"op2\"]\n\n    def map_OperatorScalarMul(self, model, operands):\n        return qt.QobjEvo(lambda t: operands[\"coeff\"](t) * operands[\"op\"](t))\n\n    def map_WaveCoefficient(self, model, operands):\n        return lambda t: operands[\"amplitude\"](t) * np.exp(\n            1j * (operands[\"frequency\"](t) * t + operands[\"phase\"](t))\n        )\n\n    def map_CoefficientAdd(self, model, operands):\n        return lambda t: operands[\"coeff1\"](t) + operands[\"coeff2\"](t)\n\n    def map_CoefficientMul(self, model, operands):\n        return lambda t: operands[\"coeff1\"](t) * operands[\"coeff2\"](t)\n\n    def map_MathNum(self, model, operands):\n        return lambda t: model.value\n\n    def map_MathImag(self, model, operands):\n        return lambda t: 1j\n\n    def map_MathVar(self, model, operands):\n        if model.name == \"t\":\n            return lambda t: t\n\n        raise ValueError(\n            f\"Unsupported variable {model.name}, only variable t is supported\"\n        )\n\n    def map_MathFunc(self, model, operands):\n        if getattr(math, model.func, None):\n            return lambda t: getattr(math, model.func)(operands[\"expr\"](t))\n\n        if model.func == \"heaviside\":\n            return lambda t: np.heaviside(operands[\"expr\"](t), 1)\n\n        if model.func == \"conj\":\n            return lambda t: np.conj(operands[\"expr\"](t))\n\n        raise ValueError(f\"Unsupported function {model.func}\")\n\n    def map_MathAdd(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) + operands[\"expr2\"](t)\n\n    def map_MathSub(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) - operands[\"expr2\"](t)\n\n    def map_MathMul(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) * operands[\"expr2\"](t)\n\n    def map_MathDiv(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) / operands[\"expr2\"](t)\n\n    def map_MathPow(self, model, operands):\n        return lambda t: operands[\"expr1\"](t) ** operands[\"expr2\"](t)\n</code></pre>"},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.QutipVM","title":"<code>QutipVM</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Rule that executes a <code>QutipExperiment</code>.</p> <p>Attributes:</p> Name Type Description <code>hilbert_space</code> <code>Dict[str, int]</code> <p>Hilbert space of the system.</p> <code>timestep</code> <code>float</code> <p>Timestep between tracked states of the evolution.</p> <code>solver</code> <code>Literal[SESolver, MESolver]</code> <p>QuTiP solver to use.</p> <code>solver_options</code> <code>Dict[str, Any]</code> <p>Qutip solver options</p> Source code in <code>src\\oqd_trical\\backend\\qutip\\vm.py</code> <pre><code>class QutipVM(RewriteRule):\n    \"\"\"\n    Rule that executes a [`QutipExperiment`][oqd_trical.backend.qutip.interface.QutipExperiment].\n\n    Attributes:\n        hilbert_space (Dict[str, int]): Hilbert space of the system.\n        timestep (float): Timestep between tracked states of the evolution.\n        solver (Literal[\"SESolver\",\"MESolver\"]): QuTiP solver to use.\n        solver_options (Dict[str,Any]): Qutip solver options\n    \"\"\"\n\n    def __init__(\n        self,\n        hilbert_space,\n        timestep,\n        *,\n        initial_state=None,\n        solver=\"SESolver\",\n        solver_options={},\n    ):\n        self.hilbert_space = hilbert_space\n        self.timestep = timestep\n\n        if initial_state:\n            if initial_state.dims[0] != list(self.hilbert_space.size.values()):\n                raise ValueError(\"Initial state incompatible with Hilbert space\")\n            self.current_state = initial_state\n        else:\n            self.current_state = tensor(\n                [\n                    basis(self.hilbert_space.size[k], 0)\n                    for k in self.hilbert_space.size.keys()\n                ]\n            )\n\n        self.states = [self.current_state]\n        self.tspan = [0.0]\n\n        self.solver = {\n            \"SESolver\": SESolver,\n            \"MESolver\": MESolver,\n        }[solver]\n        self.solver_options = solver_options\n\n    @property\n    def result(self):\n        return dict(\n            final_state=self.current_state,\n            states=self.states,\n            tspan=self.tspan,\n            frame=self.frame,\n            hilbert_space=self.hilbert_space,\n        )\n\n    def map_QutipExperiment(self, model):\n        self.frame = model.frame\n\n    def map_QutipGate(self, model):\n        tspan = np.arange(0, model.duration, self.timestep)\n\n        if tspan[-1] != model.duration:\n            tspan = np.append(tspan, model.duration)\n\n        tspan = tspan + self.tspan[-1]\n\n        empty_hamiltonian = model.hamiltonian is None\n\n        if empty_hamiltonian:\n            self.tspan.extend(list(tspan[1:] + self.tspan[-1]))\n            self.states.extend([self.current_state] * (len(tspan) - 1))\n            return\n\n        solver = self.solver(model.hamiltonian, options=self.solver_options)\n\n        res = solver.run(\n            self.current_state,\n            tspan,\n        )\n\n        self.current_state = res.final_state\n\n        self.tspan.extend(list(tspan[1:]))\n        self.states.extend(list(res.states[1:]))\n</code></pre>"},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.interface","title":"<code>interface</code>","text":""},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.interface.QutipExperiment","title":"<code>QutipExperiment</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a qutip experiment represented in terms of atomic operations expressed in terms of their Hamiltonians.</p> <p>Attributes:</p> Name Type Description <code>base</code> <code>Operator</code> <p>Free Hamiltonian.</p> <code>sequence</code> <code>List[AtomicEmulatorGate]</code> <p>List of gates to apply.</p> Source code in <code>src\\oqd_trical\\backend\\qutip\\interface.py</code> <pre><code>class QutipExperiment(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a qutip experiment represented in terms of atomic operations expressed in terms of their Hamiltonians.\n\n    Attributes:\n        base (Operator): Free Hamiltonian.\n        sequence (List[AtomicEmulatorGate]): List of gates to apply.\n\n    \"\"\"\n\n    model_config = ConfigDict(validate_assignments=True, arbitrary_types_allowed=True)\n\n    frame: Optional[QobjEvo]\n    sequence: List[QutipGate]\n</code></pre>"},{"location":"reference/backend/qutip/#oqd_trical.backend.qutip.interface.QutipGate","title":"<code>QutipGate</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a qutip gate represented in terms of atomic operations expressed in terms of their Hamiltonians.</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>Operator</code> <p>Hamiltonian to evolve by.</p> <code>duration</code> <code>float</code> <p>Time to evolve for.</p> Source code in <code>src\\oqd_trical\\backend\\qutip\\interface.py</code> <pre><code>class QutipGate(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a qutip gate represented in terms of atomic operations expressed in terms of their Hamiltonians.\n\n    Attributes:\n        hamiltonian (Operator): Hamiltonian to evolve by.\n        duration (float): Time to evolve for.\n    \"\"\"\n\n    model_config = ConfigDict(validate_assignments=True, arbitrary_types_allowed=True)\n\n    hamiltonian: Optional[QobjEvo]\n    duration: float\n</code></pre>"},{"location":"reference/compiler/analysis/","title":"Analysis","text":""},{"location":"reference/compiler/analysis/#oqd_trical.light_matter.compiler.analysis","title":"<code>oqd_trical.light_matter.compiler.analysis</code>","text":""},{"location":"reference/compiler/analysis/#oqd_trical.light_matter.compiler.analysis.HilbertSpace","title":"<code>HilbertSpace</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Represents a Hilbert space.</p> <p>Attributes:</p> Name Type Description <code>hilbert_space</code> <code>Dict[str, Optional[Set[int]]]</code> <p>Hilbert space for the AtomicEmulatorCircuit</p> <code>size</code> <code>Dict[str, int]</code> <p>Hilbert space for the AtomicEmulatorCircuit</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\analysis.py</code> <pre><code>class HilbertSpace(TypeReflectBaseModel):\n    \"\"\"\n    Represents a Hilbert space.\n\n    Attributes:\n        hilbert_space (Dict[str, Optional[Set[int]]]): Hilbert space for the AtomicEmulatorCircuit\n        size (Dict[str, int]): Hilbert space for the AtomicEmulatorCircuit\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n    hilbert_space: Dict[str, Optional[Set[int]]]\n\n    @property\n    def size(self):\n        return {\n            k: len(v) if isinstance(v, set) else 0\n            for k, v in self.hilbert_space.items()\n        }\n\n    def get_relabel_rules(self):\n        \"\"\"\n        Retrieves a relabeling scheme for the Hilbert space.\n        \"\"\"\n        relabel_rules = {}\n        for k, v in self.hilbert_space.items():\n            if k[0] == \"E\":\n                relabel_rules[k] = {i: n for n, i in enumerate(v)}\n        return relabel_rules\n</code></pre>"},{"location":"reference/compiler/analysis/#oqd_trical.light_matter.compiler.analysis.HilbertSpace.get_relabel_rules","title":"<code>get_relabel_rules()</code>","text":"<p>Retrieves a relabeling scheme for the Hilbert space.</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\analysis.py</code> <pre><code>def get_relabel_rules(self):\n    \"\"\"\n    Retrieves a relabeling scheme for the Hilbert space.\n    \"\"\"\n    relabel_rules = {}\n    for k, v in self.hilbert_space.items():\n        if k[0] == \"E\":\n            relabel_rules[k] = {i: n for n, i in enumerate(v)}\n    return relabel_rules\n</code></pre>"},{"location":"reference/compiler/analysis/#oqd_trical.light_matter.compiler.analysis.GetHilbertSpace","title":"<code>GetHilbertSpace</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Retrieves the Hilbert space for an AtomicEmulatorCircuit.</p> <p>Attributes:</p> Name Type Description <code>hilbert_space</code> <code>HilbertSpace</code> <p>Hilbert space for the AtomicEmulatorCircuit</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\analysis.py</code> <pre><code>class GetHilbertSpace(RewriteRule):\n    \"\"\"\n    Retrieves the Hilbert space for an AtomicEmulatorCircuit.\n\n    Attributes:\n        hilbert_space (HilbertSpace): Hilbert space for the AtomicEmulatorCircuit\n    \"\"\"\n\n    def __init__(self):\n        self._hilbert_space = {}\n\n    @property\n    def hilbert_space(self):\n        hilbert_space = {}\n        for k, v in self._hilbert_space.items():\n            if k[0] == \"E\" and v is None:\n                hilbert_space[k] = {0}\n            else:\n                hilbert_space[k] = v\n        return HilbertSpace(hilbert_space=hilbert_space)\n\n    def map_System(self, model):\n        for n, ion in enumerate(model.ions):\n            self._hilbert_space[f\"E{n}\"] = set(range(len(ion.levels)))\n\n        for m, mode in enumerate(model.modes):\n            self._hilbert_space[f\"P{m}\"] = None\n\n    def map_KetBra(self, model):\n        if (\n            model.subsystem not in self._hilbert_space.keys()\n            or self._hilbert_space[model.subsystem] is None\n        ):\n            self._hilbert_space[model.subsystem] = set()\n\n        self._hilbert_space[model.subsystem].update((model.ket, model.bra))\n\n    def map_Annihilation(self, model):\n        if model.subsystem in self._hilbert_space.keys():\n            return\n\n        self._hilbert_space[model.subsystem] = None\n\n    def map_Creation(self, model):\n        if model.subsystem in self._hilbert_space.keys():\n            return\n\n        self._hilbert_space[model.subsystem] = None\n\n    def map_Displacement(self, model):\n        if model.subsystem in self._hilbert_space.keys():\n            return\n\n        self._hilbert_space[model.subsystem] = None\n\n    def map_Identity(self, model):\n        if model.subsystem in self._hilbert_space.keys():\n            return\n\n        self._hilbert_space[model.subsystem] = None\n</code></pre>"},{"location":"reference/compiler/approximate/","title":"Approximation","text":""},{"location":"reference/compiler/approximate/#oqd_trical.light_matter.compiler.approximate","title":"<code>oqd_trical.light_matter.compiler.approximate</code>","text":""},{"location":"reference/compiler/approximate/#oqd_trical.light_matter.compiler.approximate.FirstOrderLambDickeApprox","title":"<code>FirstOrderLambDickeApprox</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Applies the Lamb-Dicke approximation to first order.</p> <p>Attributes:</p> Name Type Description <code>cutoff</code> <code>float</code> <p>Lamb-Dicke parameter cutoff below which approximation is applied.</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\approximate.py</code> <pre><code>class FirstOrderLambDickeApprox(RewriteRule):\n    \"\"\"\n    Applies the Lamb-Dicke approximation to first order.\n\n    Attributes:\n        cutoff (float): Lamb-Dicke parameter cutoff below which approximation is applied.\n    \"\"\"\n\n    def __init__(self, cutoff=1):\n        super().__init__()\n        self.cutoff = cutoff\n\n        self.approximated_operators = []\n\n    def map_Displacement(self, model):\n        if isinstance(model.alpha.amplitude, MathNum):\n            if np.abs(model.alpha.amplitude.value) &lt; self.cutoff:\n                self.approximated_operators.append(model)\n\n                alpha_conj = model.alpha.conj()\n                return Identity(subsystem=model.subsystem) + (\n                    model.alpha * Creation(subsystem=model.subsystem)\n                    - alpha_conj * Annihilation(subsystem=model.subsystem)\n                )\n</code></pre>"},{"location":"reference/compiler/approximate/#oqd_trical.light_matter.compiler.approximate.SecondOrderLambDickeApprox","title":"<code>SecondOrderLambDickeApprox</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Applies the Lamb-Dicke approximation to second order.</p> <p>Attributes:</p> Name Type Description <code>cutoff</code> <code>float</code> <p>Lamb-Dicke parameter cutoff below which approximation is applied.</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\approximate.py</code> <pre><code>class SecondOrderLambDickeApprox(RewriteRule):\n    \"\"\"\n    Applies the Lamb-Dicke approximation to second order.\n\n    Attributes:\n        cutoff (float): Lamb-Dicke parameter cutoff below which approximation is applied.\n    \"\"\"\n\n    def __init__(self, cutoff=1):\n        super().__init__()\n\n        self.cutoff = cutoff\n\n        self.approximated_operators = []\n\n    def map_Displacement(self, model):\n        if isinstance(model.alpha.amplitude, MathNum):\n            if np.abs(model.alpha.amplitude.value) &lt; self.cutoff:\n                self.approximated_operators.append(model)\n\n                alpha_conj = model.alpha.conj()\n                return (\n                    Identity(subsystem=model.subsystem)\n                    + (\n                        model.alpha * Creation(subsystem=model.subsystem)\n                        - alpha_conj * Annihilation(subsystem=model.subsystem)\n                    )\n                    + ConstantCoefficient(value=1 / 2)\n                    * (\n                        model.alpha * Creation(subsystem=model.subsystem)\n                        - alpha_conj * Annihilation(subsystem=model.subsystem)\n                    )\n                    * (\n                        model.alpha * Creation(subsystem=model.subsystem)\n                        - alpha_conj * Annihilation(subsystem=model.subsystem)\n                    )\n                )\n</code></pre>"},{"location":"reference/compiler/approximate/#oqd_trical.light_matter.compiler.approximate.RotatingWaveApprox","title":"<code>RotatingWaveApprox</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Applies the rotating wave approximation.</p> <p>Attributes:</p> Name Type Description <code>cutoff</code> <code>float</code> <p>Frequency cutoff above which approximation is applied.</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\approximate.py</code> <pre><code>class RotatingWaveApprox(RewriteRule):\n    \"\"\"\n    Applies the rotating wave approximation.\n\n    Attributes:\n        cutoff (float): Frequency cutoff above which approximation is applied.\n    \"\"\"\n\n    def __init__(self, cutoff):\n        super().__init__()\n\n        self.cutoff = cutoff\n\n    def map_WaveCoefficient(self, model):\n        if (\n            isinstance(model.frequency, MathNum)\n            and np.abs(model.frequency.value) &gt; self.cutoff\n        ):\n            return ConstantCoefficient(value=0)\n</code></pre>"},{"location":"reference/compiler/approximate/#oqd_trical.light_matter.compiler.approximate.RotatingReferenceFrame","title":"<code>RotatingReferenceFrame</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Moves to an interaction picture with a rotating frame of reference.</p> <p>Attributes:</p> Name Type Description <code>frame</code> <code>Operator</code> <p><code>Operator</code> that defines the rotating frame of reference</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\approximate.py</code> <pre><code>class RotatingReferenceFrame(RewriteRule):\n    \"\"\"\n    Moves to an interaction picture with a rotating frame of reference.\n\n    Attributes:\n        frame (Operator): [`Operator`][oqd_trical.light_matter.interface.operator.Operator] that defines the rotating frame of reference\n    \"\"\"\n\n    def __init__(self, frame_specs):\n        super().__init__()\n\n        self.frame_specs = frame_specs\n\n    @cached_property\n    def system(self):\n        return list(self.frame_specs.keys())\n\n    def _complete_operator(self, op, subsystem):\n        return reduce(\n            lambda x, y: x @ y,\n            [op if subsystem == s else Identity(subsystem=s) for s in self.system],\n        )\n\n    @cached_property\n    def frame(self):\n        ops = []\n        for subsystem, energy in self.frame_specs.items():\n            if subsystem[0] == \"E\":\n                ops.extend(\n                    [\n                        ConstantCoefficient(value=e)\n                        * self._complete_operator(\n                            KetBra(ket=n, bra=n, subsystem=subsystem), subsystem\n                        )\n                        for n, e in enumerate(energy)\n                    ]\n                )\n            else:\n                ops.append(\n                    ConstantCoefficient(value=energy)\n                    * self._complete_operator(\n                        Creation(subsystem=subsystem)\n                        * Annihilation(subsystem=subsystem),\n                        subsystem,\n                    )\n                )\n\n        return reduce(lambda x, y: x + y, ops)\n\n    def map_AtomicEmulatorCircuit(self, model):\n        return model.__class__(frame=self.frame, sequence=model.sequence)\n\n    def map_AtomicEmulatorGate(self, model):\n        return model.__class__(\n            hamiltonian=model.hamiltonian - self.frame, duration=model.duration\n        )\n\n    def map_KetBra(self, model):\n        return (\n            WaveCoefficient(\n                amplitude=1,\n                frequency=self.frame_specs[model.subsystem][model.ket]\n                - self.frame_specs[model.subsystem][model.bra],\n                phase=0,\n            )\n            * model\n        )\n\n    def map_Displacement(self, model):\n        alpha = model.alpha\n        return model.__class__(\n            alpha=alpha.__class__(\n                amplitude=alpha.amplitude,\n                frequency=alpha.frequency + self.frame_specs[model.subsystem],\n                phase=alpha.phase,\n            ),\n            subsystem=model.subsystem,\n        )\n\n    def map_Annihilation(self, model):\n        return (\n            WaveCoefficient(\n                amplitude=1, frequency=self.frame_specs[model.subsystem], phase=0\n            )\n            * model\n        )\n\n    def map_Creation(self, model):\n        return (\n            WaveCoefficient(\n                amplitude=1, frequency=-self.frame_specs[model.subsystem], phase=0\n            )\n            * model\n        )\n</code></pre>"},{"location":"reference/compiler/approximate/#oqd_trical.light_matter.compiler.approximate.AdiabaticElimination","title":"<code>AdiabaticElimination</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Moves to an interaction picture with a rotating frame of reference.</p> <p>Attributes:</p> Name Type Description <code>eliminated_spec</code> <code>Tuple[int, str]</code> <p>Specification of state of a subsystem to eliminate.</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\approximate.py</code> <pre><code>class AdiabaticElimination(RewriteRule):\n    \"\"\"\n    Moves to an interaction picture with a rotating frame of reference.\n\n    Attributes:\n        eliminated_spec (Tuple[int,str]): Specification of state of a subsystem to eliminate.\n    \"\"\"\n\n    # TODO currently non universal formulation for AdiabaticElimination\n    def __init__(self, eliminated_specs):\n        super().__init__()\n\n        warnings.warn(\n            \"Caution required when using adiabatic elimination, system needs to be put in the appropriate rotating reference frame.\"\n        )\n\n        self._eliminated_specs = eliminated_specs\n\n        self.matrix_elements = []\n\n    @cached_property\n    def eliminated_specs(self):\n        return self._eliminated_specs\n\n    @cached_property\n    def eliminated_state(self):\n        return self.eliminated_specs[0]\n\n    @cached_property\n    def eliminated_subsystem(self):\n        return self.eliminated_specs[1]\n\n    @property\n    def diagonal(self):\n        diagonal = list(\n            filter(lambda x: x[0] == self.eliminated_state, self.matrix_elements)\n        )\n\n        if diagonal:\n            return diagonal\n\n        raise ValueError(\n            \"Failed to apply adiabatic elimination: Diagonal matrix element of eliminated state is zero.\"\n        )\n\n    @property\n    def nondiagonal(self):\n        return list(\n            filter(lambda x: x[0] != self.eliminated_state, self.matrix_elements)\n        )\n\n    def map_AtomicEmulatorGate(self, model):\n        adiabatic_elimination_helper = _GetMatrixElements(self.eliminated_specs)\n        Post(adiabatic_elimination_helper)(model.hamiltonian)\n        self.matrix_elements = adiabatic_elimination_helper.matrix_elements\n\n    def map_KetBra(self, model):\n        if model.subsystem != self.eliminated_subsystem:\n            return\n\n        if model.ket == self.eliminated_state and model.bra == self.eliminated_state:\n            return PrunedOperator()\n\n        if model.ket == self.eliminated_state:\n            return -reduce(\n                lambda x, y: x + y,\n                [\n                    (ConstantCoefficient(value=0.5) * c / self.diagonal[0][1]).conj()\n                    * KetBra(ket=i, bra=model.bra, subsystem=model.subsystem)\n                    for (i, c) in self.nondiagonal\n                ],\n            )\n\n        if model.bra == self.eliminated_state:\n            return -reduce(\n                lambda x, y: x + y,\n                [\n                    (ConstantCoefficient(value=0.5) * c / self.diagonal[0][1])\n                    * KetBra(ket=model.ket, bra=i, subsystem=model.subsystem)\n                    for (i, c) in self.nondiagonal\n                ],\n            )\n</code></pre>"},{"location":"reference/compiler/canonicalize/","title":"Canonicalization","text":""},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize","title":"<code>oqd_trical.light_matter.compiler.canonicalize</code>","text":""},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.PruneOperator","title":"<code>PruneOperator</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Prunes an Operator AST by removing zeros</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class PruneOperator(RewriteRule):\n    \"\"\"Prunes an Operator AST by removing zeros\"\"\"\n\n    def map_OperatorAdd(self, model):\n        if isinstance(model.op1, PrunedOperator):\n            return model.op2\n        if isinstance(model.op2, PrunedOperator):\n            return model.op1\n\n    def map_OperatorMul(self, model):\n        if isinstance(model.op1, PrunedOperator) or isinstance(\n            model.op2, PrunedOperator\n        ):\n            return PrunedOperator()\n\n    def map_OperatorScalarMul(self, model):\n        if isinstance(\n            model.coeff, WaveCoefficient\n        ) and model.coeff.amplitude == MathNum(value=0):\n            return PrunedOperator()\n        if isinstance(model.op, PrunedOperator):\n            return PrunedOperator()\n\n    def map_OperatorKron(self, model):\n        if isinstance(model.op1, PrunedOperator) or isinstance(\n            model.op2, PrunedOperator\n        ):\n            return PrunedOperator()\n\n    def map_Displacement(self, model):\n        if isinstance(\n            model.alpha, WaveCoefficient\n        ) and model.alpha.amplitude == MathNum(value=0):\n            return Identity(subsystem=model.subsystem)\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.PruneZeroPowers","title":"<code>PruneZeroPowers</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Prunes a MathExpr AST by MathPow when base is zero</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class PruneZeroPowers(RewriteRule):\n    \"\"\"Prunes a MathExpr AST by MathPow when base is zero\"\"\"\n\n    def map_MathPow(self, model):\n        if model.expr1 == MathNum(value=0):\n            return MathNum(value=0)\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.OperatorDistributivity","title":"<code>OperatorDistributivity</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Implements distributivity of addition over multiplication, kronecker product and scalar multiplication</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class OperatorDistributivity(RewriteRule):\n    \"\"\"Implements distributivity of addition over multiplication, kronecker product and scalar multiplication\"\"\"\n\n    def map_OperatorMul(self, model):\n        if isinstance(model.op1, (OperatorAdd)):\n            return model.op1.__class__(\n                op1=OperatorMul(op1=model.op1.op1, op2=model.op2),\n                op2=OperatorMul(op1=model.op1.op2, op2=model.op2),\n            )\n        if isinstance(model.op2, (OperatorAdd)):\n            return model.op2.__class__(\n                op1=OperatorMul(op1=model.op1, op2=model.op2.op1),\n                op2=OperatorMul(op1=model.op1, op2=model.op2.op2),\n            )\n        if isinstance(model.op1, (OperatorKron)) and isinstance(\n            model.op2, (OperatorKron)\n        ):\n            return OperatorKron(\n                op1=OperatorMul(op1=model.op1.op1, op2=model.op2.op1),\n                op2=OperatorMul(op1=model.op1.op2, op2=model.op2.op2),\n            )\n        return None\n\n    def map_OperatorKron(self, model):\n        if isinstance(model.op1, (OperatorAdd)):\n            return model.op1.__class__(\n                op1=OperatorKron(op1=model.op1.op1, op2=model.op2),\n                op2=OperatorKron(op1=model.op1.op2, op2=model.op2),\n            )\n        if isinstance(model.op2, (OperatorAdd)):\n            return model.op2.__class__(\n                op1=OperatorKron(op1=model.op1, op2=model.op2.op1),\n                op2=OperatorKron(op1=model.op1, op2=model.op2.op2),\n            )\n        return None\n\n    def map_OperatorScalarMul(self, model):\n        if isinstance(model.op, (OperatorAdd)):\n            return model.op.__class__(\n                op1=OperatorScalarMul(op=model.op.op1, coeff=model.coeff),\n                op2=OperatorScalarMul(op=model.op.op2, coeff=model.coeff),\n            )\n        return None\n\n    pass\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.OperatorAssociativity","title":"<code>OperatorAssociativity</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Implements associativity of addition, multiplication and kronecker product</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class OperatorAssociativity(RewriteRule):\n    \"\"\"Implements associativity of addition, multiplication and kronecker product\"\"\"\n\n    def map_OperatorAdd(self, model):\n        return self._map_addmullkron(model=model)\n\n    def map_OperatorMul(self, model):\n        return self._map_addmullkron(model=model)\n\n    def map_OperatorKron(self, model):\n        return self._map_addmullkron(model=model)\n\n    def _map_addmullkron(self, model):\n        if isinstance(model.op2, model.__class__):\n            return model.__class__(\n                op1=model.__class__(op1=model.op1, op2=model.op2.op1),\n                op2=model.op2.op2,\n            )\n        return model.__class__(op1=model.op1, op2=model.op2)\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.GatherCoefficient","title":"<code>GatherCoefficient</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Gathers the coefficients of an operator into a single scalar multiplication for each term</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class GatherCoefficient(RewriteRule):\n    \"\"\"Gathers the coefficients of an operator into a single scalar multiplication for each term\"\"\"\n\n    def map_OperatorScalarMul(self, model):\n        if isinstance(model.op, OperatorScalarMul):\n            return (model.coeff * model.op.coeff) * model.op.op\n\n    def map_OperatorMul(self, model):\n        return self._map_mulkron(model)\n\n    def map_OperatorKron(self, model):\n        return self._map_mulkron(model)\n\n    def _map_mulkron(self, model):\n        if isinstance(model.op1, OperatorScalarMul) and isinstance(\n            model.op2, OperatorScalarMul\n        ):\n            return (\n                model.op1.coeff\n                * model.op2.coeff\n                * model.__class__(op1=model.op1.op, op2=model.op2.op)\n            )\n        if isinstance(model.op1, OperatorScalarMul):\n            return model.op1.coeff * model.__class__(op1=model.op1.op, op2=model.op2)\n\n        if isinstance(model.op2, OperatorScalarMul):\n            return model.op2.coeff * model.__class__(op1=model.op1, op2=model.op2.op)\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.CoefficientDistributivity","title":"<code>CoefficientDistributivity</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Implements distributivity of addition over multiplication on coefficient</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class CoefficientDistributivity(RewriteRule):\n    \"\"\"Implements distributivity of addition over multiplication on coefficient\"\"\"\n\n    def map_CoefficientMul(self, model):\n        if isinstance(model.coeff1, (CoefficientAdd)):\n            return model.coeff1.__class__(\n                coeff1=CoefficientMul(coeff1=model.coeff1.coeff1, coeff2=model.coeff2),\n                coeff2=CoefficientMul(coeff1=model.coeff1.coeff2, coeff2=model.coeff2),\n            )\n        if isinstance(model.coeff2, (CoefficientAdd)):\n            return model.coeff2.__class__(\n                coeff1=CoefficientMul(coeff1=model.coeff1, coeff2=model.coeff2.coeff1),\n                coeff2=CoefficientMul(coeff1=model.coeff1, coeff2=model.coeff2.coeff2),\n            )\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.CoefficientAssociativity","title":"<code>CoefficientAssociativity</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Implements associativity of addition, multiplication on coefficient</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class CoefficientAssociativity(RewriteRule):\n    \"\"\"Implements associativity of addition, multiplication on coefficient\"\"\"\n\n    def map_CoefficientAdd(self, model):\n        return self._map_addmul(model=model)\n\n    def map_CoefficientMul(self, model):\n        return self._map_addmul(model=model)\n\n    def _map_addmul(self, model):\n        if isinstance(model.coeff2, model.__class__):\n            return model.__class__(\n                coeff1=model.__class__(coeff1=model.coeff1, coeff2=model.coeff2.coeff1),\n                coeff2=model.coeff2.coeff2,\n            )\n        return model.__class__(coeff1=model.coeff1, coeff2=model.coeff2)\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.ScaleTerms","title":"<code>ScaleTerms</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Adds a scalar multiplication for each term if it does not exist</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class ScaleTerms(RewriteRule):\n    \"\"\"Adds a scalar multiplication for each term if it does not exist\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.op_add_root = False\n\n    def map_AtomicEmulatorGate(self, model):\n        self.op_add_root = False\n\n    def map_OperatorAdd(self, model):\n        self.op_add_root = True\n        if isinstance(model.op1, Union[OperatorAdd, OperatorScalarMul]):\n            op1 = model.op1\n        else:\n            op1 = ConstantCoefficient(value=1) * model.op1\n        if isinstance(model.op2, OperatorScalarMul):\n            op2 = model.op2\n        else:\n            op2 = ConstantCoefficient(value=1) * model.op2\n        return op1 + op2\n\n    def map_OperatorScalarMul(self, model):\n        self.op_add_root = True\n        pass\n\n    def map_Operator(self, model):\n        if not self.op_add_root:\n            self.op_add_root = True\n            return ConstantCoefficient(value=1) * model\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize._CombineTermsHelper","title":"<code>_CombineTermsHelper</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Helper for combining terms of the same operator by combining their coefficients</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class _CombineTermsHelper(RewriteRule):\n    \"\"\"Helper for combining terms of the same operator by combining their coefficients\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        self.operators = []\n\n    @property\n    def coefficients(self):\n        return [o[0] for o in self.operators]\n\n    @property\n    def terms(self):\n        return [o[1] for o in self.operators]\n\n    def emit(self):\n        if self.operators == []:\n            return PrunedOperator()\n        return reduce(\n            lambda op1, op2: op1 + op2,\n            [o[0] * o[1] for o in self.operators],\n        )\n\n    def map_OperatorScalarMul(self, model):\n        if model.op in self.terms:\n            i = self.terms.index(model.op)\n            self.operators[i] = (model.coeff + self.coefficients[i], model.op)\n        else:\n            self.operators.append((model.coeff, model.op))\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.CombineTerms","title":"<code>CombineTerms</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Combines terms of the same operator by combining their coefficients</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>class CombineTerms(RewriteRule):\n    \"\"\"Combines terms of the same operator by combining their coefficients\"\"\"\n\n    def map_AtomicEmulatorCircuit(self, model):\n        return model.__class__(frame=model.frame, sequence=model.sequence)\n\n    def map_AtomicEmulatorGate(self, model):\n        combiner = _CombineTermsHelper()\n        Pre(combiner)(model)\n\n        return model.__class__(hamiltonian=combiner.emit(), duration=model.duration)\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.canonicalize_math_factory","title":"<code>canonicalize_math_factory()</code>","text":"<p>Creates a new instance of the canonicalization pass for math expressions</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>def canonicalize_math_factory():\n    \"\"\"Creates a new instance of the canonicalization pass for math expressions\"\"\"\n    return FixedPoint(\n        Post(\n            Chain(\n                PruneZeroPowers(),\n                SimplifyMathExpr(),\n                DistributeMathExpr(),\n                ProperOrderMathExpr(),\n            )\n        )\n    )\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.canonicalize_coefficient_factory","title":"<code>canonicalize_coefficient_factory()</code>","text":"<p>Creates a new instance of the canonicalization pass for coefficients</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>def canonicalize_coefficient_factory():\n    \"\"\"Creates a new instance of the canonicalization pass for coefficients\"\"\"\n    return FixedPoint(\n        Post(\n            Chain(\n                PruneCoefficient(),\n                CoefficientDistributivity(),\n                CombineCoefficient(),\n                CoefficientAssociativity(),\n            )\n        )\n    )\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.canonicalize_operator_factory","title":"<code>canonicalize_operator_factory()</code>","text":"<p>Creates a new instance of the canonicalization pass for operators</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>def canonicalize_operator_factory():\n    \"\"\"Creates a new instance of the canonicalization pass for operators\"\"\"\n    return FixedPoint(\n        Post(\n            Chain(\n                OperatorDistributivity(),\n                GatherCoefficient(),\n                OperatorAssociativity(),\n            )\n        )\n    )\n</code></pre>"},{"location":"reference/compiler/canonicalize/#oqd_trical.light_matter.compiler.canonicalize.canonicalize_emulator_circuit_factory","title":"<code>canonicalize_emulator_circuit_factory()</code>","text":"<p>Creates a new instance of the canonicalization pass for AtomicEmulatorCircuit</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\canonicalize.py</code> <pre><code>def canonicalize_emulator_circuit_factory():\n    \"\"\"Creates a new instance of the canonicalization pass for AtomicEmulatorCircuit\"\"\"\n    return Chain(\n        canonicalize_operator_factory(),\n        canonicalize_coefficient_factory(),\n        canonicalize_math_factory(),\n        Post(PruneOperator()),\n        Pre(ScaleTerms()),\n        Post(CombineTerms()),\n        canonicalize_coefficient_factory(),\n        canonicalize_math_factory(),\n        Post(PruneOperator()),\n        Post(ResolveRelativeTime()),\n    )\n</code></pre>"},{"location":"reference/compiler/codegen/","title":"Code Generation","text":""},{"location":"reference/compiler/codegen/#oqd_trical.light_matter.compiler","title":"<code>oqd_trical.light_matter.compiler</code>","text":""},{"location":"reference/compiler/codegen/#oqd_trical.light_matter.compiler.codegen","title":"<code>codegen</code>","text":""},{"location":"reference/compiler/codegen/#oqd_trical.light_matter.compiler.codegen.ConstructHamiltonian","title":"<code>ConstructHamiltonian</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>Maps an AtomicCircuit to an AtomicEmulatorCircuit replaces laser descriptions of operations with Hamiltonian description of operations</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\codegen.py</code> <pre><code>class ConstructHamiltonian(ConversionRule):\n    \"\"\"Maps an AtomicCircuit to an AtomicEmulatorCircuit replaces laser descriptions of operations with Hamiltonian description of operations\"\"\"\n\n    def map_AtomicCircuit(self, model, operands):\n        gates = (\n            [operands[\"protocol\"]]\n            if isinstance(operands[\"protocol\"], AtomicEmulatorGate)\n            else operands[\"protocol\"]\n        )\n        for gate in gates:\n            gate.hamiltonian = gate.hamiltonian + operands[\"system\"]\n\n        return AtomicEmulatorCircuit(sequence=gates)\n\n    def map_System(self, model, operands):\n        self.N = len(model.ions)\n        self.M = len(model.modes)\n\n        self.ions = model.ions\n        self.modes = model.modes\n\n        ops = []\n        for n, ion in enumerate(model.ions):\n            ops.append(\n                reduce(\n                    lambda x, y: x @ y,\n                    [\n                        (\n                            self._map_Ion(ion, n)\n                            if i == n\n                            else Identity(\n                                subsystem=f\"E{i}\" if i &lt; self.N else f\"P{i - self.N}\"\n                            )\n                        )\n                        for i in range(self.N + self.M)\n                    ],\n                )\n            )\n\n        for m, mode in enumerate(model.modes):\n            ops.append(\n                reduce(\n                    lambda x, y: x @ y,\n                    [\n                        (\n                            self._map_Phonon(mode, m)\n                            if i == self.N + m\n                            else Identity(\n                                subsystem=f\"E{i}\" if i &lt; self.N else f\"P{i - self.N}\"\n                            )\n                        )\n                        for i in range(self.N + self.M)\n                    ],\n                )\n            )\n\n        op = reduce(lambda x, y: x + y, ops)\n        return op\n\n    def _map_Ion(self, model, index):\n        ops = [\n            WaveCoefficient(amplitude=level.energy, frequency=0, phase=0)\n            * KetBra(ket=n, bra=n, subsystem=f\"E{index}\")\n            for n, level in enumerate(model.levels)\n        ]\n\n        op = reduce(lambda x, y: x + y, ops)\n        return op\n\n    def _map_Phonon(self, model, index):\n        return WaveCoefficient(amplitude=model.energy, frequency=0, phase=0) * (\n            Creation(subsystem=f\"P{index}\") * Annihilation(subsystem=f\"P{index}\")\n        )\n\n    def map_Beam(self, model, operands):\n        I = intensity_from_laser(model)  # noqa: E741\n\n        angular_frequency = (\n            abs(model.transition.level2.energy - model.transition.level1.energy)\n            + model.detuning\n        )\n        wavevector = angular_frequency * np.array(model.wavevector) / cst.c\n\n        ops = []\n        if self.modes:\n            displacement_plus = []\n            displacement_minus = []\n            for m, mode in enumerate(self.modes):\n                eta = np.dot(\n                    wavevector,\n                    mode.eigenvector[model.target * 3 : model.target * 3 + 3],\n                ) * np.sqrt(\n                    cst.hbar\n                    / (2 * self.ions[model.target].mass * cst.m_u * mode.energy)\n                )\n\n                displacement_plus.append(\n                    Displacement(\n                        alpha=WaveCoefficient(\n                            amplitude=eta, frequency=0, phase=np.pi / 2\n                        ),\n                        subsystem=f\"P{m}\",\n                    )\n                )\n                displacement_minus.append(\n                    Displacement(\n                        alpha=WaveCoefficient(\n                            amplitude=eta, frequency=0, phase=-np.pi / 2\n                        ),\n                        subsystem=f\"P{m}\",\n                    )\n                )\n\n            displacement_plus = reduce(lambda x, y: x @ y, displacement_plus)\n            displacement_minus = reduce(lambda x, y: x @ y, displacement_minus)\n\n            for transition in self.ions[model.target].transitions:\n                rabi = rabi_from_intensity(model, transition, I)\n\n                ops.append(\n                    (\n                        reduce(\n                            lambda x, y: x @ y,\n                            [\n                                (\n                                    WaveCoefficient(\n                                        amplitude=rabi / 2,\n                                        frequency=-angular_frequency,\n                                        phase=model.phase,\n                                    )\n                                    * (\n                                        KetBra(\n                                            ket=self.ions[model.target].levels.index(\n                                                transition.level1\n                                            ),\n                                            bra=self.ions[model.target].levels.index(\n                                                transition.level2\n                                            ),\n                                            subsystem=f\"E{model.target}\",\n                                        )\n                                        + KetBra(\n                                            ket=self.ions[model.target].levels.index(\n                                                transition.level2\n                                            ),\n                                            bra=self.ions[model.target].levels.index(\n                                                transition.level1\n                                            ),\n                                            subsystem=f\"E{model.target}\",\n                                        )\n                                    )\n                                    if i == model.target\n                                    else Identity(subsystem=f\"E{i}\")\n                                )\n                                for i in range(self.N)\n                            ],\n                        )\n                        @ displacement_plus\n                    )\n                )\n\n                ops.append(\n                    (\n                        reduce(\n                            lambda x, y: x @ y,\n                            [\n                                (\n                                    WaveCoefficient(\n                                        amplitude=rabi / 2,\n                                        frequency=angular_frequency,\n                                        phase=-model.phase,\n                                    )\n                                    * (\n                                        KetBra(\n                                            ket=self.ions[model.target].levels.index(\n                                                transition.level1\n                                            ),\n                                            bra=self.ions[model.target].levels.index(\n                                                transition.level2\n                                            ),\n                                            subsystem=f\"E{model.target}\",\n                                        )\n                                        + KetBra(\n                                            ket=self.ions[model.target].levels.index(\n                                                transition.level2\n                                            ),\n                                            bra=self.ions[model.target].levels.index(\n                                                transition.level1\n                                            ),\n                                            subsystem=f\"E{model.target}\",\n                                        )\n                                    )\n                                    if i == model.target\n                                    else Identity(subsystem=f\"E{i}\")\n                                )\n                                for i in range(self.N)\n                            ],\n                        )\n                        @ displacement_minus\n                    )\n                )\n\n        else:\n            for transition in self.ions[model.target].transitions:\n                rabi = rabi_from_intensity(model, transition, I)\n\n                ops.append(\n                    reduce(\n                        lambda x, y: x @ y,\n                        [\n                            (\n                                WaveCoefficient(\n                                    amplitude=rabi / 2,\n                                    frequency=angular_frequency,\n                                    phase=model.phase,\n                                )\n                                * (\n                                    KetBra(\n                                        ket=self.ions[model.target].levels.index(\n                                            transition.level1\n                                        ),\n                                        bra=self.ions[model.target].levels.index(\n                                            transition.level2\n                                        ),\n                                        subsystem=f\"E{model.target}\",\n                                    )\n                                    + KetBra(\n                                        ket=self.ions[model.target].levels.index(\n                                            transition.level2\n                                        ),\n                                        bra=self.ions[model.target].levels.index(\n                                            transition.level1\n                                        ),\n                                        subsystem=f\"E{model.target}\",\n                                    )\n                                )\n                                if i == model.target\n                                else Identity(subsystem=f\"E{i}\")\n                            )\n                            for i in range(self.N)\n                        ],\n                    )\n                )\n\n        op = reduce(lambda x, y: x + y, ops)\n        return op\n\n    def map_Pulse(self, model, operands):\n        return AtomicEmulatorGate(\n            hamiltonian=operands[\"beam\"],\n            duration=model.duration,\n        )\n\n    def map_ParallelProtocol(self, model, operands):\n        # TODO: Implement correct procedure for SequentialProtocol\n        # within ParallelProtocol\n        for p in model.sequence:\n            if isinstance(p, SequentialProtocol):\n                raise NotImplementedError(\n                    \"SequentialProtocol within ParallelProtocol currently unsupported\"\n                )\n\n        duration_max = np.max([_op.duration for _op in operands[\"sequence\"]])\n\n        ops = []\n        for _op in operands[\"sequence\"]:\n            if _op.duration != duration_max:\n                ops.append(\n                    _op.hamiltonian\n                    * WaveCoefficient(\n                        amplitude=MathFunc(\n                            func=\"heaviside\", expr=_op.duration - MathVar(name=\"t\")\n                        ),\n                        frequency=0,\n                        phase=0,\n                    )\n                )\n            else:\n                ops.append(_op.hamiltonian)\n\n        op = reduce(lambda x, y: x + y, ops)\n        return AtomicEmulatorGate(hamiltonian=op, duration=duration_max)\n\n    def map_SequentialProtocol(self, model, operands):\n        return operands[\"sequence\"]\n</code></pre>"},{"location":"reference/compiler/codegen/#oqd_trical.light_matter.compiler.utils","title":"<code>utils</code>","text":""},{"location":"reference/compiler/codegen/#oqd_trical.light_matter.compiler.utils.compute_matrix_element","title":"<code>compute_matrix_element(laser, transition)</code>","text":"<p>Computes matrix element corresponding to a laser interacting with a particular transition</p> <p>Parameters:</p> Name Type Description Default <code>laser</code> <code>Beam</code> <p>laser to compute matrix element of</p> required <code>transition</code> <code>Transition</code> <p>transition to compute matrix element of</p> required <p>Returns:</p> Name Type Description <code>matrix_element</code> <code>float</code> <p>Multipole matrix elements corresponding to the interaction between the laser and the transition</p> Warning <p>Currently implemented for only <code>E1</code> and <code>E2</code> transitions.</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\utils.py</code> <pre><code>def compute_matrix_element(laser, transition):\n    \"\"\"Computes matrix element corresponding to a laser interacting with a particular transition\n\n    Args:\n        laser (Beam): laser to compute matrix element of\n        transition (Transition): transition to compute matrix element of\n\n    Returns:\n        matrix_element (float): Multipole matrix elements corresponding to the interaction between the laser and the transition\n\n    Warning:\n        Currently implemented for only `E1` and `E2` transitions.\n    \"\"\"\n\n    # If this happens there's probably an error with the ion species card\n    if transition.level1.nuclear != transition.level2.nuclear:\n        raise ValueError(\n            \"Different nuclear spins between two levels in transition:\", transition\n        )\n\n    # Just by convention; these orderings are set upon instantiation of an Ion object\n    if transition.level1.energy &gt; transition.level2.energy:\n        raise ValueError(\"Expected energy of level2 &gt; energy of level1\")\n\n    polarization = np.array(laser.polarization).T  # make it a column vector\n    wavevector = laser.wavevector\n\n    J1, J2, F1, F2, M1, M2, E1, E2, I, A = (  # noqa: E741\n        transition.level1.spin_orbital,\n        transition.level2.spin_orbital,\n        transition.level1.spin_orbital_nuclear,\n        transition.level2.spin_orbital_nuclear,\n        transition.level1.spin_orbital_nuclear_magnetization,\n        transition.level2.spin_orbital_nuclear_magnetization,\n        transition.level1.energy,\n        transition.level2.energy,\n        transition.level1.nuclear,\n        transition.einsteinA,\n    )\n\n    q = M2 - M1\n\n    omega = E2 - E1\n\n    # --- M1 transition multipole ---\n    if transition.multipole == \"M1\":\n        # The Einstein A coefficient for an M1 transition is given by:\n        #   A(M1) = (16 * pi^3)/(3 * hbar) * (omega^3/c^3) * (|&lt;J2||\u03bc||J1&gt;|^2/(2J2+1))\n\n        # Solving for the reduced matrix element (expressed in units of the Bohr magneton, \u03bc_B) :\n        #   |&lt;J2||\u03bc||J1&gt;|/\u03bc_B = sqrt((3 * hbar * c^3 * A * (2J2+1))/(16 * pi^3 * omega^3)) / \u03bc_B\n\n        # Reference: I. I. Sobelman, \"Atomic Spectra and Radiative Transitions\", 2nd ed., Springer (1992).\n\n        # A unit term is definied so that when multiplied by standard angular momentum factors,  the full matrix is reproduced\n\n        units_term = np.sqrt(\n            (3 * cst.hbar * cst.epsilon_0 * cst.c**5 * A) / (16 * np.pi**3 * omega**3)\n        )\n\n        hyperfine_term = np.sqrt((2 * F2 + 1) * (2 * F1 + 1)) * wigner_6j(\n            J1, J2, 1, F2, F1, I\n        )\n\n        # For M1 transitions the operator is a vector operator coupling to the magnetic field\n        # Plane wave: magnetic field is proportional to cross product of wavevector and electric field polarization\n        B_field = np.cross(wavevector, polarization)\n\n        # Define a spherical basis for a vector (identical to the one used for E1):\n        polarization_map = {\n            -1: 1 / np.sqrt(2) * np.array([1, 1j, 0]),\n            0: np.array([0, 0, 1]),\n            1: 1 / np.sqrt(2) * np.array([1, -1j, 0]),\n        }\n\n        geometry_term = (\n            np.sqrt(2 * J2 + 1)\n            * polarization_map[q].dot(B_field)\n            * wigner_3j(F2, 1, F1, M2, -q, -M1)\n        )\n\n        return float(\n            (abs(units_term) * abs(geometry_term) * abs(hyperfine_term)).evalf()\n        )\n\n    # --- E1 transition multipole ---\n    if transition.multipole == \"E1\":\n        units_term = np.sqrt(\n            (3 * np.pi * cst.epsilon_0 * cst.hbar * cst.c**3 * A)\n            / (omega**3 * cst.e**2)\n        )\n        hyperfine_term = np.sqrt((2 * F2 + 1) * (2 * F1 + 1)) * wigner_6j(\n            J1, J2, 1, F2, F1, I\n        )\n\n        # q -&gt; polarization\n        polarization_map = {\n            -1: 1 / np.sqrt(2) * np.array([1, 1j, 0]),\n            0: np.array([0, 0, 1]),\n            1: 1 / np.sqrt(2) * np.array([1, -1j, 0]),\n        }\n\n        geometry_term = (\n            np.sqrt(2 * J2 + 1)\n            * polarization_map[q].dot(polarization)\n            * wigner_3j(F2, 1, F1, M2, -q, -M1)\n        )\n\n        return float(\n            (abs(units_term) * abs(geometry_term) * abs(hyperfine_term)).evalf()\n        )\n\n    # --- E2 transition multipole ---\n    elif transition.multipole == \"E2\":\n        units_term = np.sqrt(\n            (15 * np.pi * cst.epsilon_0 * cst.hbar * cst.c**3 * A)\n            / (omega**3 * cst.e**2)\n        )  # &lt;- anomalous constants I needed to add... hmm\n        hyperfine_term = np.sqrt((2 * F2 + 1) * (2 * F1 + 1)) * wigner_6j(\n            J1, J2, 2, F2, F1, I\n        )\n\n        # q -&gt; polarization\n        polarization_map = {\n            -2: 1 / np.sqrt(6) * np.array([[1, 1j, 0], [1j, -1, 0], [0, 0, 0]]),\n            -1: 1 / np.sqrt(6) * np.array([[0, 0, 1], [0, 0, 1j], [1, 1j, 0]]),\n            0: 1 / 3 * np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 2]]),\n            1: 1 / np.sqrt(6) * np.array([[0, 0, -1], [0, 0, 1j], [-1, 1j, 0]]),\n            2: 1 / np.sqrt(6) * np.array([[1, -1j, 0], [-1j, -1, 0], [0, 0, 0]]),\n        }\n\n        geometry_term = (\n            np.sqrt(2 * J2 + 1)\n            * wavevector.dot(np.matmul(polarization_map[q], polarization))\n            * wigner_3j(F2, 2, F1, M2, -q, -M1)\n        )\n\n        return float(\n            (abs(units_term) * abs(geometry_term) * abs(hyperfine_term)).evalf()\n        )\n\n    else:\n        raise ValueError(\n            \"Currently only support dipole and quadrupole allowed transitions\"\n        )\n</code></pre>"},{"location":"reference/compiler/codegen/#oqd_trical.light_matter.compiler.utils.rabi_from_intensity","title":"<code>rabi_from_intensity(laser, transition, intensity)</code>","text":"<p>Computes a transition's resonant rabi frequency when addressed by a laser with intensity</p> <p>Parameters:</p> Name Type Description Default <code>laser</code> <code>Beam</code> <p>laser to compute resonant rabi frequency of</p> required <code>transition</code> <code>Transition</code> <p>transition to compute resonant rabi frequency of</p> required <code>intensity</code> <code>float</code> <p>intensity of laser</p> required <p>Returns:</p> Name Type Description <code>rabi_frequency</code> <code>float</code> <p>resonant rabi frequency corresponding to the interaction between the laser and transition</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\utils.py</code> <pre><code>def rabi_from_intensity(laser, transition, intensity):\n    \"\"\"Computes a transition's resonant rabi frequency when addressed by a laser with intensity\n\n    Args:\n        laser (Beam): laser to compute resonant rabi frequency of\n        transition (Transition): transition to compute resonant rabi frequency of\n        intensity (float): intensity of laser\n\n    Returns:\n        rabi_frequency (float): resonant rabi frequency corresponding to the interaction between the laser and transition\n    \"\"\"\n\n    matrix_elem = compute_matrix_element(laser, transition)\n\n    if transition.multipole[0] == \"E\":\n        E = (2 * intensity / (cst.epsilon_0 * cst.c)) ** 0.5\n        return matrix_elem * E * cst.e / cst.hbar\n    if transition.multipole[0] == \"M\":\n        B = (2 * intensity / (cst.epsilon_0 * cst.c**3)) ** 0.5\n        return matrix_elem * B / cst.hbar\n</code></pre>"},{"location":"reference/compiler/codegen/#oqd_trical.light_matter.compiler.utils.intensity_from_laser","title":"<code>intensity_from_laser(laser)</code>","text":"<p>Computes the intensity from a laser</p> <p>Parameters:</p> Name Type Description Default <code>laser</code> <code>Beam</code> <p>laser to compute intensity of.</p> required <p>Returns:</p> Name Type Description <code>intensity</code> <code>float</code> <p>intensity of the laser</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\utils.py</code> <pre><code>def intensity_from_laser(laser):\n    \"\"\"Computes the intensity from a laser\n\n    Args:\n        laser (Beam): laser to compute intensity of.\n\n    Returns:\n        intensity (float): intensity of the laser\n    \"\"\"\n    matrix_elem = compute_matrix_element(laser, laser.transition)\n\n    if laser.transition.multipole[0] == \"E\":\n        return (\n            cst.c\n            * cst.epsilon_0\n            / 2\n            * (cst.hbar * laser.rabi / (matrix_elem * cst.e)) ** 2\n        )  # noqa: E741\n\n    if laser.transition.multipole[0] == \"M\":\n        return cst.c**3 * cst.epsilon_0 / 2 * (cst.hbar * laser.rabi / matrix_elem) ** 2  # noqa: E741\n</code></pre>"},{"location":"reference/compiler/visualize/","title":"Visualization","text":""},{"location":"reference/compiler/visualize/#oqd_trical.light_matter.compiler.visualization","title":"<code>oqd_trical.light_matter.compiler.visualization</code>","text":""},{"location":"reference/compiler/visualize/#oqd_trical.light_matter.compiler.visualization.CoefficientPrinter","title":"<code>CoefficientPrinter</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>Prints Coefficients in a pretty manner</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\visualization.py</code> <pre><code>class CoefficientPrinter(ConversionRule):\n    \"\"\"Prints Coefficients in a pretty manner\"\"\"\n\n    def map_MathExpr(self, model, operands):\n        return Post(PrintMathExpr())(model)\n\n    def map_MathAdd(self, model, operands):\n        return f\"({Post(PrintMathExpr())(model)})\"\n\n    def map_WaveCoefficient(self, model, operands):\n        frequency_term = (\n            f\"{operands['frequency']} * t\"\n            if model.frequency != MathNum(value=0)\n            else \"\"\n        )\n        phase_term = f\"{operands['phase']}\" if model.phase != MathNum(value=0) else \"\"\n\n        wave_term = (\n            f\" * exp(1j * ({frequency_term}{' + ' if frequency_term and phase_term else ''}{phase_term}))\"\n            if phase_term or frequency_term\n            else \"\"\n        )\n\n        return f\"{operands['amplitude']}{wave_term}\"\n\n    def map_CoefficientAdd(self, model, operands):\n        return f\"{'(' + operands['coeff1'] + ')' if isinstance(model.coeff1, CoefficientAdd) else operands['coeff1']} + {'(' + operands['coeff2'] + ')' if isinstance(model.coeff2, CoefficientAdd) else operands['coeff2']}\"\n\n    def map_CoefficientMul(self, model, operands):\n        return f\"{'(' + operands['coeff1'] + ')' if isinstance(model.coeff1, CoefficientAdd) else operands['coeff1']} * {'(' + operands['coeff2'] + ')' if isinstance(model.coeff2, CoefficientAdd) else operands['coeff2']}\"\n</code></pre>"},{"location":"reference/compiler/visualize/#oqd_trical.light_matter.compiler.visualization.OperatorPrinter","title":"<code>OperatorPrinter</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>Prints Operators in a pretty manner</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\visualization.py</code> <pre><code>class OperatorPrinter(ConversionRule):\n    \"\"\"Prints Operators in a pretty manner\"\"\"\n\n    def map_KetBra(self, model, operands):\n        return f\"|{model.ket}&gt;&lt;{model.bra}|_{model.subsystem}\"\n\n    def map_Annihilation(self, model, operands):\n        return f\"A_{model.subsystem}\"\n\n    def map_Creation(self, model, operands):\n        return f\"C_{model.subsystem}\"\n\n    def map_Identity(self, model, operands):\n        return f\"I_{model.subsystem}\"\n\n    def map_PrunedOperator(self, model, operands):\n        return \"PrunedOperator\"\n\n    def map_Displacement(self, model, operands):\n        return f\"D({operands['alpha']})_{model.subsystem}\"\n\n    def map_OperatorAdd(self, model, operands):\n        return f\"{operands['op1']} + {operands['op2']}\"\n\n    def map_OperatorMul(self, model, operands):\n        return f\"{'(' + operands['op1'] + ')' if isinstance(model.op1, OperatorAdd) else operands['op1']} * {'(' + operands['op2'] + ')' if isinstance(model.op2, OperatorAdd) else operands['op2']}\"\n\n    def map_OperatorKron(self, model, operands):\n        return f\"{'(' + operands['op1'] + ')' if isinstance(model.op1, OperatorAdd) else operands['op1']} @ {'(' + operands['op2'] + ')' if isinstance(model.op2, OperatorAdd) else operands['op2']}\"\n\n    def map_OperatorScalarMul(self, model, operands):\n        return f\"{'(' + operands['coeff'] + ')' if isinstance(model.coeff, CoefficientAdd) else operands['coeff']} * {'(' + operands['op'] + ')' if isinstance(model.op, OperatorAdd) else operands['op']}\"\n\n    def map_Coefficient(self, model, operands):\n        return Post(CoefficientPrinter())(model)\n</code></pre>"},{"location":"reference/compiler/visualize/#oqd_trical.light_matter.compiler.visualization.CondensedOperatorPrettyPrint","title":"<code>CondensedOperatorPrettyPrint</code>","text":"<p>               Bases: <code>PrettyPrint</code></p> <p>Prints An AtomicEmulatorCircuit in a pretty manner</p> Source code in <code>src\\oqd_trical\\light_matter\\compiler\\visualization.py</code> <pre><code>class CondensedOperatorPrettyPrint(PrettyPrint):\n    \"\"\"Prints An AtomicEmulatorCircuit in a pretty manner\"\"\"\n\n    def map_Operator(self, model, operands):\n        return f\"Operator({Post(OperatorPrinter())(model)})\"\n</code></pre>"},{"location":"reference/mechanical/potential/","title":"Potential","text":""},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential","title":"<code>oqd_trical.mechanical.potential</code>","text":""},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.Potential","title":"<code>Potential</code>","text":"<p>               Bases: <code>Base</code></p> <p>Object representing a general potential.</p> <p>Parameters:</p> Name Type Description Default <code>d2phi</code> <code>Callable</code> <p>Function that takes two strings representing the derivative variables and outputs the function corresponding to the derivative of the potential with respect to the derivative variables.</p> required <code>dphi</code> <code>Callable</code> <p>Function that takes a string representing the derivative variable and outputs the function corresponding to the derivative of the potential with respect to the derivative variable.</p> required <code>phi</code> <code>Callable</code> <p>Function representing the potential.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class Potential(Base):\n    \"\"\"\n    Object representing a general potential.\n\n    Args:\n        d2phi (Callable): Function that takes two strings representing the derivative variables and outputs the function corresponding to the derivative of the potential with respect to the derivative variables.\n        dphi (Callable): Function that takes a string representing the derivative variable and outputs the function corresponding to the derivative of the potential with respect to the derivative variable.\n        phi (Callable ): Function representing the potential.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n    \"\"\"\n\n    def __init__(self, phi, dphi, d2phi, **kwargs):\n        super(Potential, self).__init__()\n\n        self.phi = phi\n        self.dphi = dphi\n        self.d2phi = d2phi\n\n        params = {\"dim\": 3}\n        params.update(kwargs)\n        self.__dict__.update(params)\n        self.params = params\n        pass\n\n    def __add__(self, other):\n        for i in np.intersect1d(list(self.params.keys()), list(other.params.keys())):\n            assert (\n                self.params[i] == other.params[i]\n            ), \"Potentials with incompatible dimensions\"\n\n        params = {}\n        params.update(self.params)\n        params.update(other.params)\n\n        def phi(x):\n            return self.phi(x) + other.phi(x)\n\n        def dphi(var):\n            return lambda x: self.dphi(var)(x) + other.dphi(var)(x)\n\n        def d2phi(var1, var2):\n            return lambda x: self.d2phi(var1, var2)(x) + other.d2phi(var1, var2)(x)\n\n        return Potential(phi, dphi, d2phi, **params)\n\n    def __sub__(self, other):\n        for i in np.intersect1d(list(self.params.keys()), list(other.params.keys())):\n            assert (\n                self.params[i] == other.params[i]\n            ), \"Potentials with incompatible dimensions\"\n\n        params = {}\n        params.update(self.params)\n        params.update(other.params)\n\n        def phi(x):\n            return self.phi(x) - other.phi(x)\n\n        def dphi(var):\n            return lambda x: self.dphi(var)(x) - other.dphi(var)(x)\n\n        def d2phi(var1, var2):\n            return lambda x: self.d2phi(var1, var2)(x) - other.d2phi(var1, var2)(x)\n\n        return Potential(phi, dphi, d2phi, **params)\n\n    def __mul__(self, multiplier):\n        def phi(x):\n            return self.phi(x) * multiplier\n\n        def dphi(var):\n            return lambda x: self.dphi(var)(x) * multiplier\n\n        def d2phi(var1, var2):\n            return lambda x: self.d2phi(var1, var2)(x) * multiplier\n\n        return Potential(phi, dphi, d2phi, **self.params)\n\n    def __rmul__(self, multiplier):\n        return self * multiplier\n\n    def __truediv__(self, divisor):\n        def phi(x):\n            return self.phi(x) / divisor\n\n        def dphi(var):\n            return lambda x: self.dphi(var)(x) / divisor\n\n        def d2phi(var1, var2):\n            return lambda x: self.d2phi(var1, var2)(x) / divisor\n\n        return Potential(phi, dphi, d2phi, **self.params)\n\n    def __call__(self, x):\n        return self.phi(x)\n\n    def first_derivative(self, var):\n        \"\"\"\n        Calculates the first derivative of the potential with respect to a variable.\n\n        Args:\n            var (str): Derivative variable.\n\n        Returns:\n            (Callable): Function corresponding to the first derivative of the potential with respect to the derivative variable.\n        \"\"\"\n        return self.dphi(var)\n\n    def second_derivative(self, var1, var2):\n        \"\"\"\n        Calculates the second derivative of the potential with respect to two variables.\n\n        Args:\n            var1 (str): first derivative variable.\n            var2 (str): second derivative variable.\n\n        Returns:\n            (Callable): Function corresponding to the second derivative of the potential with respect to the derivative variables.\n        \"\"\"\n        return self.d2phi(var1, var2)\n\n    def gradient(self):\n        \"\"\"\n        Calculates the gradient of the potential.\n\n        Returns:\n            (Callable): Function corresponding to the gradient of the potential.\n        \"\"\"\n\n        def grad_phi(x):\n            grad_phi_x = np.empty(self.N * self.dim)\n\n            i = 0\n            for var in itr.product(\n                [\"x\", \"y\", \"z\"][: self.dim], np.arange(self.N, dtype=int)\n            ):\n                grad_phi_x[i] = self.dphi(var)(x)\n                i += 1\n            return grad_phi_x\n\n        return grad_phi\n\n    def hessian(self):\n        \"\"\"\n        Calculates the Hessian of the potential.\n\n        Returns:\n            (Callable): Function corresponding to the Hessian of the potential.\n        \"\"\"\n\n        def hess_phi(x):\n            hess_phi_x = np.empty((self.N * self.dim, self.N * self.dim))\n\n            i = 0\n            for var1 in itr.product(\n                [\"x\", \"y\", \"z\"][: self.dim], np.arange(self.N, dtype=int)\n            ):\n                j = 0\n                for var2 in itr.product(\n                    [\"x\", \"y\", \"z\"][: self.dim], np.arange(self.N, dtype=int)\n                ):\n                    hess_phi_x[i, j] = self.d2phi(var1, var2)(x)\n                    j += 1\n                i += 1\n            return hess_phi_x\n\n        return hess_phi\n\n    def nondimensionalize(self, l):  # noqa: E741\n        \"\"\"\n        Nondimensionalizes a Potential with a length scale.\n\n        Args:\n            l (float): Length scale.\n\n        Returns:\n            (Potential): Potential representing the nondimensionalized coulomb potential.\n        \"\"\"\n\n        def nd_phi(x):\n            return self.phi(x * l)\n\n        def nd_dphi(var):\n            return lambda x: self.dphi(var)(x * l)\n\n        def nd_d2phi(var1, var2):\n            return lambda x: self.d2phi(var1, var2)(x * l)\n\n        return (\n            Potential(nd_phi, nd_dphi, nd_d2phi, **self.params)\n            * l\n            / (cst.k_e * cst.e**2)\n        )\n\n    def update_params(self, **kwargs):\n        \"\"\"\n        Updates parameters, i.e. params attribute, of a Potential object.\n\n        Args:\n            dim (int): Dimension of the system.\n            N (int): Number of Ions.\n        \"\"\"\n        self.params.update(kwargs)\n        self.__dict__.update(self.params)\n        pass\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.Potential.first_derivative","title":"<code>first_derivative(var)</code>","text":"<p>Calculates the first derivative of the potential with respect to a variable.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Derivative variable.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Function corresponding to the first derivative of the potential with respect to the derivative variable.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>def first_derivative(self, var):\n    \"\"\"\n    Calculates the first derivative of the potential with respect to a variable.\n\n    Args:\n        var (str): Derivative variable.\n\n    Returns:\n        (Callable): Function corresponding to the first derivative of the potential with respect to the derivative variable.\n    \"\"\"\n    return self.dphi(var)\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.Potential.second_derivative","title":"<code>second_derivative(var1, var2)</code>","text":"<p>Calculates the second derivative of the potential with respect to two variables.</p> <p>Parameters:</p> Name Type Description Default <code>var1</code> <code>str</code> <p>first derivative variable.</p> required <code>var2</code> <code>str</code> <p>second derivative variable.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Function corresponding to the second derivative of the potential with respect to the derivative variables.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>def second_derivative(self, var1, var2):\n    \"\"\"\n    Calculates the second derivative of the potential with respect to two variables.\n\n    Args:\n        var1 (str): first derivative variable.\n        var2 (str): second derivative variable.\n\n    Returns:\n        (Callable): Function corresponding to the second derivative of the potential with respect to the derivative variables.\n    \"\"\"\n    return self.d2phi(var1, var2)\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.Potential.gradient","title":"<code>gradient()</code>","text":"<p>Calculates the gradient of the potential.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>Function corresponding to the gradient of the potential.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>def gradient(self):\n    \"\"\"\n    Calculates the gradient of the potential.\n\n    Returns:\n        (Callable): Function corresponding to the gradient of the potential.\n    \"\"\"\n\n    def grad_phi(x):\n        grad_phi_x = np.empty(self.N * self.dim)\n\n        i = 0\n        for var in itr.product(\n            [\"x\", \"y\", \"z\"][: self.dim], np.arange(self.N, dtype=int)\n        ):\n            grad_phi_x[i] = self.dphi(var)(x)\n            i += 1\n        return grad_phi_x\n\n    return grad_phi\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.Potential.hessian","title":"<code>hessian()</code>","text":"<p>Calculates the Hessian of the potential.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>Function corresponding to the Hessian of the potential.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>def hessian(self):\n    \"\"\"\n    Calculates the Hessian of the potential.\n\n    Returns:\n        (Callable): Function corresponding to the Hessian of the potential.\n    \"\"\"\n\n    def hess_phi(x):\n        hess_phi_x = np.empty((self.N * self.dim, self.N * self.dim))\n\n        i = 0\n        for var1 in itr.product(\n            [\"x\", \"y\", \"z\"][: self.dim], np.arange(self.N, dtype=int)\n        ):\n            j = 0\n            for var2 in itr.product(\n                [\"x\", \"y\", \"z\"][: self.dim], np.arange(self.N, dtype=int)\n            ):\n                hess_phi_x[i, j] = self.d2phi(var1, var2)(x)\n                j += 1\n            i += 1\n        return hess_phi_x\n\n    return hess_phi\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.Potential.nondimensionalize","title":"<code>nondimensionalize(l)</code>","text":"<p>Nondimensionalizes a Potential with a length scale.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Length scale.</p> required <p>Returns:</p> Type Description <code>Potential</code> <p>Potential representing the nondimensionalized coulomb potential.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>def nondimensionalize(self, l):  # noqa: E741\n    \"\"\"\n    Nondimensionalizes a Potential with a length scale.\n\n    Args:\n        l (float): Length scale.\n\n    Returns:\n        (Potential): Potential representing the nondimensionalized coulomb potential.\n    \"\"\"\n\n    def nd_phi(x):\n        return self.phi(x * l)\n\n    def nd_dphi(var):\n        return lambda x: self.dphi(var)(x * l)\n\n    def nd_d2phi(var1, var2):\n        return lambda x: self.d2phi(var1, var2)(x * l)\n\n    return (\n        Potential(nd_phi, nd_dphi, nd_d2phi, **self.params)\n        * l\n        / (cst.k_e * cst.e**2)\n    )\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.Potential.update_params","title":"<code>update_params(**kwargs)</code>","text":"<p>Updates parameters, i.e. params attribute, of a Potential object.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimension of the system.</p> required <code>N</code> <code>int</code> <p>Number of Ions.</p> required Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>def update_params(self, **kwargs):\n    \"\"\"\n    Updates parameters, i.e. params attribute, of a Potential object.\n\n    Args:\n        dim (int): Dimension of the system.\n        N (int): Number of Ions.\n    \"\"\"\n    self.params.update(kwargs)\n    self.__dict__.update(self.params)\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.CoulombPotential","title":"<code>CoulombPotential</code>","text":"<p>               Bases: <code>Potential</code></p> <p>Object representing a coulomb potential.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of ions.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> <code>N</code> <code>int</code> <p>Number of ions.</p> <code>q</code> <code>float</code> <p>Charge of ions.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class CoulombPotential(Potential):\n    \"\"\"\n    Object representing a coulomb potential.\n\n    Args:\n        N (int): Number of ions.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n        N (int): Number of ions.\n        q (float): Charge of ions.\n    \"\"\"\n\n    def __init__(self, N, **kwargs):\n        params = {\"dim\": 3, \"N\": N, \"q\": cst.e}\n        params.update(kwargs)\n\n        super(CoulombPotential, self).__init__(\n            self.__call__, self.first_derivative, self.second_derivative, **params\n        )\n        pass\n\n    def __call__(self, x):\n        i, j = (\n            np.fromiter(itr.chain(*itr.combinations(range(self.N), 2)), dtype=int)\n            .reshape(-1, 2)\n            .transpose()\n        )\n        nxij = np.linalg.norm(x[i] - x[j], axis=-1)\n        return cst.k_e * self.q**2 * (1 / nxij).sum()\n\n    def first_derivative(self, var):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var[0]]\n        i = int(var[1:] if isinstance(var, str) else var[1:][0])\n        j = np.delete(np.arange(self.N, dtype=int), i)\n\n        def dphi_dai(x):\n            xia = x[i, a]\n            xja = x[j, a]\n            nxij = np.linalg.norm(x[i] - x[j], axis=-1)\n            return cst.k_e * self.q**2 * ((xja - xia) / nxij**3).sum()\n\n        return dphi_dai\n\n    def second_derivative(self, var1, var2):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var1[0]]\n        b = {\"x\": 0, \"y\": 1, \"z\": 2}[var2[0]]\n        i = int(var1[1:] if isinstance(var1, str) else var1[1:][0])\n        j = int(var2[1:] if isinstance(var2, str) else var2[1:][0])\n\n        def d2phi_daidbj(x):\n            if i == j:\n                k = np.delete(np.arange(self.N, dtype=int), i)\n                xia = x[i, a]\n                xka = x[k, a]\n                xib = x[i, b]\n                xkb = x[k, b]\n                nxik = np.linalg.norm(x[i] - x[k], axis=-1)\n                if a == b:\n                    return (\n                        cst.k_e\n                        * self.q**2\n                        * (-1 / nxik**3 + 3 * (xka - xia) ** 2 / nxik**5).sum()\n                    )\n                else:\n                    return (\n                        cst.k_e\n                        * self.q**2\n                        * (3 * (xka - xia) * (xkb - xib) / nxik**5).sum()\n                    )\n            else:\n                xia = x[i, a]\n                xja = x[j, a]\n                xib = x[i, b]\n                xjb = x[j, b]\n                nxij = np.linalg.norm(x[i] - x[j])\n                if a == b:\n                    return (\n                        cst.k_e\n                        * self.q**2\n                        * (1 / nxij**3 - 3 * (xja - xia) ** 2 / nxij**5)\n                    )\n                else:\n                    return (\n                        cst.k_e * self.q**2 * (-3 * (xja - xia) * (xjb - xib) / nxij**5)\n                    )\n\n        return d2phi_daidbj\n\n    def nondimensionalize(self, l):  # noqa: E741\n        return self / (cst.k_e * cst.e**2)\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.PolynomialPotential","title":"<code>PolynomialPotential</code>","text":"<p>               Bases: <code>Potential</code></p> <p>Object representing a polynomial potential.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>ndarray[float]</code> <p>Coefficients of the polynomial potential.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class PolynomialPotential(Potential):\n    \"\"\"\n    Object representing a polynomial potential.\n\n    Args:\n        alpha (np.ndarray[float]): Coefficients of the polynomial potential.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n    \"\"\"\n\n    def __init__(self, alpha, **kwargs):\n        self.alpha = np.array(alpha)\n        self.deg = np.array(alpha.shape)\n\n        params = {\"dim\": len(alpha.shape)}\n        params.update(kwargs)\n\n        super(PolynomialPotential, self).__init__(\n            self.__call__, self.first_derivative, self.second_derivative, **params\n        )\n        pass\n\n    def __call__(self, x):\n        return {1: poly.polyval, 2: poly.polyval2d, 3: poly.polyval3d}[self.dim](\n            *x.transpose(), self.alpha\n        ).sum()\n\n    def first_derivative(self, var):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var[0]]\n        i = int(var[1:] if isinstance(var, str) else var[1:][0])\n\n        beta = poly.polyder(self.alpha, axis=a)\n\n        def dphi_dai(x):\n            return {1: poly.polyval, 2: poly.polyval2d, 3: poly.polyval3d}[self.dim](\n                *x[i], beta\n            )\n\n        return dphi_dai\n\n    def second_derivative(self, var1, var2):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var1[0]]\n        b = {\"x\": 0, \"y\": 1, \"z\": 2}[var2[0]]\n        i = int(var1[1:] if isinstance(var1, str) else var1[1:][0])\n        j = int(var2[1:] if isinstance(var2, str) else var2[1:][0])\n\n        beta = poly.polyder(self.alpha, axis=a)\n        gamma = poly.polyder(beta, axis=b)\n\n        if i == j:\n\n            def d2phi_daidbj(x):\n                return {\n                    1: poly.polyval,\n                    2: poly.polyval2d,\n                    3: poly.polyval3d,\n                }[self.dim](*x[i], gamma)\n        else:\n\n            def d2phi_daidbj(x):\n                return 0.0\n\n        return d2phi_daidbj\n\n    def nondimensionalize(self, l):  # noqa: E741\n        alpha = (\n            l ** np.indices(self.alpha.shape).sum(0)\n            * self.alpha\n            * (l / (cst.k_e * cst.e**2))\n        )\n        return PolynomialPotential(alpha, **self.params)\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.GaussianOpticalPotential","title":"<code>GaussianOpticalPotential</code>","text":"<p>               Bases: <code>Potential</code></p> <p>Object representing a potential caused by a Gaussian beam.</p> <p>Parameters:</p> Name Type Description Default <code>focal_point</code> <code>ndarray[float]</code> <p>Center of the Gaussian beam.</p> required <code>power</code> <code>float</code> <p>Power of Gaussian beam.</p> required <code>wavelength</code> <code>float</code> <p>Wavelength of Gaussian beam.</p> required <code>beam_waist</code> <code>float</code> <p>Waist of Gaussian beam.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> <code>m</code> <code>float</code> <p>Mass of ions.</p> <code>Omega_bar</code> <code>float</code> <p>Rabi frequency per root intensity.</p> <code>transition_wavelength</code> <code>float</code> <p>Wavelength of the transition that creates the optical trap.</p> <code>refractive_index</code> <code>float</code> <p>Refractive index of medium Gaussian beam is propagating through.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class GaussianOpticalPotential(Potential):\n    \"\"\"\n    Object representing a potential caused by a Gaussian beam.\n\n    Args:\n        focal_point (np.ndarray[float]): Center of the Gaussian beam.\n        power (float): Power of Gaussian beam.\n        wavelength (float): Wavelength of Gaussian beam.\n        beam_waist (float): Waist of Gaussian beam.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n        m (float): Mass of ions.\n        Omega_bar (float): Rabi frequency per root intensity.\n        transition_wavelength (float): Wavelength of the transition that creates the optical trap.\n        refractive_index (float): Refractive index of medium Gaussian beam is propagating through.\n    \"\"\"\n\n    def __init__(self, focal_point, power, wavelength, beam_waist, **opt_kwargs):\n        self.params = {\"dim\": 3}\n\n        opt_params = {\n            \"m\": 171 * cst.m_u,\n            \"Omega_bar\": 2.23e6,\n            \"transition_wavelength\": 369.52e-9,\n            \"refractive_index\": 1,\n            \"focal_point\": focal_point,\n            \"power\": power,\n            \"wavelength\": wavelength,\n            \"beam_waist\": beam_waist,\n        }\n        opt_params.update(opt_kwargs)\n        self.__dict__.update(opt_params)\n        self.opt_params = opt_params\n\n        nu = cst.convert_lamb_to_omega(wavelength)\n        nu_transition = cst.convert_lamb_to_omega(opt_params[\"transition_wavelength\"])\n        Delta = nu - nu_transition\n        x_R = np.pi * beam_waist**2 * opt_params[\"refractive_index\"] / wavelength\n        I = 2 * power / (np.pi * beam_waist**2)  # noqa: E741\n        Omega = opt_params[\"Omega_bar\"] * np.sqrt(np.abs(I))\n        omega_x = np.sqrt(\n            np.abs(\n                cst.hbar\n                * self.Omega_bar**2\n                * power\n                * wavelength**2\n                / (self.refractive_index**2 * np.pi**3 * Delta * beam_waist**6 * self.m)\n            )\n        )\n        omega_y = omega_z = np.sqrt(\n            np.abs(\n                2\n                * cst.hbar\n                * self.Omega_bar**2\n                * power\n                / (np.pi * Delta * beam_waist**4 * self.m)\n            )\n        )\n\n        self.nu = nu\n        self.nu_transition = nu_transition\n        self.Delta = Delta\n        self.x_R = x_R\n        self.I = I\n        self.Omega = Omega\n        self.stark_shift = np.abs(Omega**2 / (4 * Delta))\n        self.V = cst.hbar * self.Omega_bar**2 * self.I / (4 * self.Delta)\n        self.omega = np.array([omega_x, omega_y, omega_z])\n\n        super(GaussianOpticalPotential, self).__init__(\n            self.__call__, self.first_derivative, self.second_derivative, **self.params\n        )\n        pass\n\n    def __call__(self, x):\n        delta_x = x - self.focal_point\n        w0 = self.beam_waist\n        w = w0 * np.sqrt(1 + (delta_x[:, 0] / self.x_R) ** 2)\n        V = self.V\n        r = np.sqrt(delta_x[:, 1] ** 2 + delta_x[:, 2] ** 2)\n        e = np.exp(-2 * r**2 / w**2)\n        return (V * e * w0**2 / w**2).sum()\n\n    def first_derivative(self, var):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var[0]]\n        i = int(var[1:] if isinstance(var, str) else var[1:][0])\n\n        def dphi_dai(x):\n            V = self.V\n            w0 = self.beam_waist\n            xR = self.x_R\n            delta_x = x[i] - self.focal_point\n            w = w0 * np.sqrt(1 + (delta_x[0] / xR) ** 2)\n            r = np.sqrt(delta_x[1] ** 2 + delta_x[2] ** 2)\n            e = np.exp(-2 * r**2 / w**2)\n            if a == 0:\n                return (2 * V * e * w0**4 * delta_x[0] * (2 * r**2 - w**2)) / (\n                    w**6 * xR**2\n                )\n            else:\n                return -4 * V * e * w0**2 * delta_x[a] / w**4\n\n        return dphi_dai\n\n    def second_derivative(self, var1, var2):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var1[0]]\n        b = {\"x\": 0, \"y\": 1, \"z\": 2}[var2[0]]\n        i = int(var1[1:] if isinstance(var1, str) else var1[1:][0])\n        j = int(var2[1:] if isinstance(var2, str) else var2[1:][0])\n\n        def d2phi_daidbj(x):\n            V = self.V\n            w0 = self.beam_waist\n            xR = self.x_R\n            delta_x = x[i] - self.focal_point\n            w = w0 * np.sqrt(1 + (delta_x[0] / xR) ** 2)\n            r = np.sqrt(delta_x[1] ** 2 + delta_x[2] ** 2)\n            e = np.exp(-2 * r**2 / w**2)\n            if i != j:\n                return 0\n            else:\n                if a == b == 0:\n                    return (\n                        -2\n                        * V\n                        * w0**4\n                        * (\n                            w**6 * xR**2\n                            - 4 * w**4 * w0**2 * delta_x[0] ** 2\n                            + 8 * w**2 * w0**2 * delta_x[0] ** 2 * r**2\n                            - 2\n                            * r**2\n                            * (\n                                w**4 * xR**2\n                                - 4 * w**2 * w0**2 * delta_x[0] ** 2\n                                + 4 * w0**2 * delta_x[0] ** 2 * r**2\n                            )\n                        )\n                        * e\n                        / (w**10 * xR**4)\n                    )\n                elif a == b:\n                    return -4 * V * w0**2 * (w**2 - 4 * delta_x[a] ** 2) * e / w**6\n\n                elif a == 0:\n                    return (\n                        16\n                        * V\n                        * w0**4\n                        * delta_x[0]\n                        * delta_x[b]\n                        * (w**2 - r**2)\n                        * e\n                        / (w**8 * xR**2)\n                    )\n                elif b == 0:\n                    return (\n                        16\n                        * V\n                        * w0**4\n                        * delta_x[0]\n                        * delta_x[a]\n                        * (w**2 - r**2)\n                        * e\n                        / (w**8 * xR**2)\n                    )\n                else:\n                    return 16 * V * w0**2 * delta_x[1] * delta_x[2] * e / w**6\n\n        return d2phi_daidbj\n\n    def nondimensionalize(self, l):  # noqa: E741\n        ndgop = (\n            GaussianOpticalPotential(\n                self.focal_point / l,\n                self.power,\n                self.wavelength,\n                self.beam_waist / l,\n                m=self.m,\n                Omega_bar=self.Omega_bar / l,\n                transition_wavelength=self.transition_wavelength,\n                refractive_index=self.refractive_index,\n            )\n            * l\n            / (cst.k_e * cst.e**2)\n        )\n        ndgop.update_params(**self.params)\n        return ndgop\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.SymbolicPotential","title":"<code>SymbolicPotential</code>","text":"<p>               Bases: <code>Potential</code></p> <p>Object representing a symbolically defined potential, same for all ions.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>Symbolic expression of the potential.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class SymbolicPotential(Potential):\n    \"\"\"\n    Object representing a symbolically defined potential, same for all ions.\n\n    Args:\n        expr (str): Symbolic expression of the potential.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n    \"\"\"\n\n    def __init__(self, expr, **kwargs):\n        self.expr = expr\n\n        params = {\"dim\": 3}\n        params.update(kwargs)\n        self.__dict__.update(params)\n        self.params = params\n\n        self.symbol = [sympy.Symbol([\"x\", \"y\", \"z\"][i]) for i in range(self.dim)]\n        self.lambdified_expr = sympy.utilities.lambdify(self.symbol, expr)\n\n        super(SymbolicPotential, self).__init__(\n            self.__call__, self.first_derivative, self.second_derivative, **params\n        )\n        pass\n\n    def __call__(self, x):\n        return self.lambdified_expr(*x.transpose()).sum()\n\n    def evaluate(self, x):\n        return self.lambdified_expr(*x.transpose())\n\n    def first_derivative(self, var):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var[0]]\n        i = int(var[1:] if isinstance(var, str) else var[1:][0])\n\n        def dphi_dai(x):\n            return sympy.utilities.lambdify(\n                self.symbol, sympy.diff(self.expr, self.symbol[a])\n            )(*x[i])\n\n        return dphi_dai\n\n    def second_derivative(self, var1, var2):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var1[0]]\n        b = {\"x\": 0, \"y\": 1, \"z\": 2}[var2[0]]\n        i = int(var1[1:] if isinstance(var1, str) else var1[1:][0])\n        j = int(var2[1:] if isinstance(var2, str) else var2[1:][0])\n\n        if i == j:\n\n            def d2phi_daidbj(x):\n                return sympy.utilities.lambdify(\n                    self.symbol, sympy.diff(self.expr, self.symbol[a], self.symbol[b])\n                )(*x[i])\n        else:\n\n            def d2phi_daidbj(x):\n                return 0\n\n        return d2phi_daidbj\n\n    def nondimensionalize(self, l):  # noqa: E741\n        expr = self.expr.subs({k: k * l for k in self.symbol}) * (\n            l / (cst.k_e * cst.e**2)\n        )\n        return SymbolicPotential(expr, **self.params)\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.AdvancedSymbolicPotential","title":"<code>AdvancedSymbolicPotential</code>","text":"<p>               Bases: <code>Potential</code></p> <p>Object representing a symbolically defined potential that need not be the same for all ions.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>Symbolic expression of the potential.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> <code>N</code> <code>int</code> <p>Number of ions.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class AdvancedSymbolicPotential(Potential):\n    \"\"\"\n    Object representing a symbolically defined potential that need not be the same for all ions.\n\n    Args:\n        expr (str): Symbolic expression of the potential.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n        N (int): Number of ions.\n    \"\"\"\n\n    def __init__(self, N, expr, **kwargs):\n        self.expr = expr\n\n        params = {\"dim\": 3, \"N\": N}\n        params.update(kwargs)\n        self.__dict__.update(params)\n        self.params = params\n\n        self.symbol = np.array(\n            [\n                [\n                    sympy.Symbol([\"x{}\", \"y{}\", \"z{}\"][i].format(j))\n                    for i in range(self.dim)\n                ]\n                for j in range(N)\n            ]\n        ).flatten()\n        self.lambdified_expr = sympy.utilities.lambdify(self.symbol, expr)\n\n        super(AdvancedSymbolicPotential, self).__init__(\n            self.__call__, self.first_derivative, self.second_derivative, **params\n        )\n        pass\n\n    def __call__(self, x):\n        x = np.array(x)\n        return self.lambdified_expr(*x.flatten())\n\n    def first_derivative(self, var):\n        a = var[0]\n        i = int(var[1:] if isinstance(var, str) else var[1:][0])\n\n        def dphi_dai(x):\n            x = np.array(x)\n            return sympy.utilities.lambdify(\n                self.symbol, sympy.diff(self.expr, a + str(i))\n            )(*x.flatten())\n\n        return dphi_dai\n\n    def second_derivative(self, var1, var2):\n        a = var1[0]\n        b = var2[0]\n        i = int(var1[1:] if isinstance(var1, str) else var1[1:][0])\n        j = int(var2[1:] if isinstance(var2, str) else var2[1:][0])\n\n        def d2phi_daidbj(x):\n            x = np.array(x)\n            return sympy.utilities.lambdify(\n                self.symbol, sympy.diff(self.expr, a + str(i), b + str(j))\n            )(*x.flatten())\n\n        return d2phi_daidbj\n\n    def nondimensionalize(self, l):  # noqa: E741\n        expr = self.expr.subs({k: k * l for k in self.symbol}) * (\n            l / (cst.k_e * cst.e**2)\n        )\n        params = self.params\n        if \"N\" in params.keys():\n            params.pop(\"N\")\n        return AdvancedSymbolicPotential(self.N, expr, **params)\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.SymbolicOpticalPotential","title":"<code>SymbolicOpticalPotential</code>","text":"<p>               Bases: <code>SymbolicPotential</code></p> <p>Object representing a general optical potential symbolically.</p> <p>Parameters:</p> Name Type Description Default <code>intensity_expr</code> <code>str</code> <p>Expression for the intensity of the optical potential.</p> required <code>wavelength</code> <code>float</code> <p>Wavelength of the optical potential.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> <code>m</code> <code>float</code> <p>Mass of ions.</p> <code>Omega_bar</code> <code>float</code> <p>Rabi frequency per root intensity.</p> <code>transition_wavelength</code> <code>float</code> <p>Wavelength of the transition that creates the optical trap.</p> <code>refractive_index</code> <code>float</code> <p>Refractive index of medium Gaussian beam is propagating through.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class SymbolicOpticalPotential(SymbolicPotential):\n    \"\"\"\n    Object representing a general optical potential symbolically.\n\n    Args:\n        intensity_expr (str): Expression for the intensity of the optical potential.\n        wavelength (float): Wavelength of the optical potential.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n        m (float): Mass of ions.\n        Omega_bar (float): Rabi frequency per root intensity.\n        transition_wavelength (float): Wavelength of the transition that creates the optical trap.\n        refractive_index (float): Refractive index of medium Gaussian beam is propagating through.\n    \"\"\"\n\n    def __init__(self, intensity_expr, wavelength, **kwargs):\n        self.params = {\"dim\": 3}\n\n        self.intensity_expr = intensity_expr\n        self.wavelength = wavelength\n\n        opt_params = {\n            \"m\": 171 * cst.m_u,\n            \"Omega_bar\": 2.23e6,\n            \"transition_wavelength\": 369.52e-9,\n            \"refractive_index\": 1,\n        }\n        opt_params.update(kwargs)\n        self.__dict__.update(opt_params)\n        self.opt_params = opt_params\n\n        nu = cst.convert_lamb_to_omega(wavelength)\n        nu_transition = cst.convert_lamb_to_omega(opt_params[\"transition_wavelength\"])\n        Delta = nu - nu_transition\n\n        self.nu = nu\n        self.nu_transition = nu_transition\n        self.Delta = Delta\n\n        expr = cst.hbar * opt_params[\"Omega_bar\"] ** 2 * intensity_expr / (4 * Delta)\n\n        super(SymbolicOpticalPotential, self).__init__(expr, **self.params)\n        pass\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.AutoDiffPotential","title":"<code>AutoDiffPotential</code>","text":"<p>               Bases: <code>Potential</code></p> <p>Object representing a functionally defined potential for the system of ions that uses automatic differentiation to calculate derivatives of the potential.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Callable</code> <p>function of the potential that is defined using the numpy submodule of autograd package.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class AutoDiffPotential(Potential):\n    \"\"\"\n    Object representing a functionally defined potential for the system of ions that uses automatic differentiation to calculate derivatives of the potential.\n\n    Args:\n        expr (Callable): function of the potential that is defined using the numpy submodule of autograd package.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n    \"\"\"\n\n    def __init__(self, expr, **kwargs):\n        self.expr = expr\n\n        params = {\"dim\": 3}\n        params.update(kwargs)\n        self.__dict__.update(params)\n        self.params = params\n\n        super(AutoDiffPotential, self).__init__(\n            self.__call__, self.first_derivative, self.second_derivative, **params\n        )\n        pass\n\n    def __call__(self, x):\n        return self.expr(x)\n\n    def gradient(self):\n        def flatten_expr(x):\n            return self.expr(x.reshape(self.dim, -1).transpose())\n\n        return lambda x: ag.jacobian(flatten_expr, 0)(x.transpose().reshape(-1))\n\n    def hessian(self):\n        def flatten_expr(x):\n            return self.expr(x.reshape(self.dim, -1).transpose())\n\n        return lambda x: ag.hessian(flatten_expr, 0)(x.transpose().reshape(-1))\n\n    def first_derivative(self, var):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var[0]]\n        i = int(var[1:] if isinstance(var, str) else var[1:][0])\n        return lambda x: self.gradient()(x)[a * self.N + i]\n\n    def second_derivative(self, var1, var2):\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[var1[0]]\n        b = {\"x\": 0, \"y\": 1, \"z\": 2}[var2[0]]\n        i = int(var1[1:] if isinstance(var1, str) else var1[1:][0])\n        j = int(var2[1:] if isinstance(var2, str) else var2[1:][0])\n        return lambda x: self.hessian()(x)[a * self.N + i][b * self.N + j]\n\n    def nondimensionalize(self, l):  # noqa: E741\n        def expr(x):\n            return self.expr(x * l) * l / (cst.k_e * cst.e**2)\n\n        ndadp = AutoDiffPotential(expr, **self.params)\n        ndadp.update_params(**self.params)\n        return ndadp\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/potential/#oqd_trical.mechanical.potential.OpticalPotential","title":"<code>OpticalPotential</code>","text":"<p>               Bases: <code>AutoDiffPotential</code></p> <p>Object representing a general optical potential functionally using automatic differentiation to calculate the derivatives.</p> <p>Parameters:</p> Name Type Description Default <code>intensity_expr</code> <code>Callable</code> <p>function of the expression for intensity of the optical potential that is defined using the numpy submodule of autograd package.</p> required <code>wavelength</code> <code>float</code> <p>Wavelength of the optical potential.</p> required <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> <code>m</code> <code>float</code> <p>Mass of ions.</p> <code>Omega_bar</code> <code>float</code> <p>Rabi frequency per root intensity.</p> <code>transition_wavelength</code> <code>float</code> <p>Wavelength of the transition that creates the optical trap.</p> <code>refractive_index</code> <code>float</code> <p>Refractive index of medium Gaussian beam is propagating through.</p> Source code in <code>src\\oqd_trical\\mechanical\\potential.py</code> <pre><code>class OpticalPotential(AutoDiffPotential):\n    \"\"\"\n    Object representing a general optical potential functionally using automatic differentiation to calculate the derivatives.\n\n    Args:\n        intensity_expr (Callable): function of the expression for intensity of the optical potential that is defined using the numpy submodule of autograd package.\n        wavelength (float): Wavelength of the optical potential.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n        m (float): Mass of ions.\n        Omega_bar (float): Rabi frequency per root intensity.\n        transition_wavelength (float): Wavelength of the transition that creates the optical trap.\n        refractive_index (float): Refractive index of medium Gaussian beam is propagating through.\n    \"\"\"\n\n    def __init__(self, intensity_expr, wavelength, **opt_kwargs):\n        self.params = {\"dim\": 3}\n\n        self.intensity_expr = intensity_expr\n        self.wavelength = wavelength\n\n        opt_params = {\n            \"m\": 171 * cst.m_u,\n            \"Omega_bar\": 2.23e6,\n            \"transition_wavelength\": 369.52e-9,\n            \"refractive_index\": 1,\n            \"wavelength\": wavelength,\n        }\n        opt_params.update(opt_kwargs)\n        self.__dict__.update(opt_params)\n        self.opt_params = opt_params\n\n        nu = cst.convert_lamb_to_omega(wavelength)\n        nu_transition = cst.convert_lamb_to_omega(opt_params[\"transition_wavelength\"])\n        Delta = nu - nu_transition\n\n        self.nu = nu\n        self.nu_transition = nu_transition\n        self.Delta = Delta\n\n        def expr(x):\n            return (\n                cst.hbar\n                * opt_params[\"Omega_bar\"] ** 2\n                * intensity_expr(x)\n                / (4 * Delta)\n            )\n\n        super(OpticalPotential, self).__init__(expr, **self.params)\n        pass\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/spinlattice/","title":"Spin Lattice","text":""},{"location":"reference/mechanical/spinlattice/#oqd_trical.mechanical.spinlattice","title":"<code>oqd_trical.mechanical.spinlattice</code>","text":""},{"location":"reference/mechanical/spinlattice/#oqd_trical.mechanical.spinlattice.SpinLattice","title":"<code>SpinLattice</code>","text":"<p>               Bases: <code>Base</code></p> <p>Object representing a spin lattice system.</p> <p>Parameters:</p> Name Type Description Default <code>J</code> <code>ndarray[float]</code> <p>Interaction graph of the spin lattice system.</p> required Source code in <code>src\\oqd_trical\\mechanical\\spinlattice.py</code> <pre><code>class SpinLattice(Base):\n    \"\"\"\n    Object representing a spin lattice system.\n\n    Args:\n        J (np.ndarray[float]): Interaction graph of the spin lattice system.\n    \"\"\"\n\n    def __init__(self, J):\n        super(SpinLattice, self).__init__()\n\n        self.J = J\n        self.N = J.shape[0]\n        pass\n\n    def plot_interaction_graph(self, **kwargs):\n        \"\"\"Plots the normal mode frequencies of the ions\n\n        Args:\n            fig (matplotlib.figure.Figure): Figure for plot.\n            idx (int): 3 digit integer representing position of the subplot.\n            plot_type (str): Type of plot.\n\n        Returns:\n            ax (Union[matplotlib.axes._subplots.Axes3DSubplot, matplotlib.axes._subplots.AxesSubplot]): Axes of the plot\n        \"\"\"\n        plot3d_params = {\n            \"fig\": plt.figure() if \"fig\" not in kwargs.keys() else None,\n            \"idx\": 111,\n            \"plot_type\": \"bar3d\",\n        }\n        plot3d_params.update(kwargs)\n\n        N = self.N\n        Z = self.J\n\n        if plot3d_params[\"plot_type\"] == \"bar3d\":\n            ax = plot3d_params[\"fig\"].add_subplot(plot3d_params[\"idx\"], projection=\"3d\")\n\n            Z = np.transpose(Z)\n\n            X, Y = np.meshgrid(np.linspace(0, N - 1, N), np.linspace(0, N - 1, N))\n\n            X = X.flatten()\n            Y = Y.flatten()\n            Z = Z.flatten()\n\n            W = Z - Z.min()\n            frac = W / W.max()\n            norm = colors.Normalize(frac.min(), frac.max())\n            color = cm.gist_rainbow(norm(frac))\n\n            ax.bar3d(X, Y, np.zeros(len(Z)), 1, 1, Z, color=color)\n            ax.set_xlabel(r\"$i$\")\n            ax.set_ylabel(r\"$j$\")\n            ax.set_zlabel(r\"$J$\")\n            ax.set_xticks(np.linspace(0.5, N - 0.5, N))\n            ax.set_xticklabels(range(N))\n            ax.set_yticks(np.linspace(0.5, N - 0.5, N))\n            ax.set_yticklabels(range(N))\n            ax.set_xlim(0, N)\n            ax.set_ylim(0, N)\n            ax.set_zlim(min(0, 1.1 * Z.min()), 1.1 * Z.max())\n        elif plot3d_params[\"plot_type\"] == \"imshow\":\n            ax = plot3d_params[\"fig\"].add_subplot(plot3d_params[\"idx\"])\n            ax.imshow(Z, cmap=cm.gist_rainbow)\n            ax.set_xlabel(r\"$j$\")\n            ax.set_ylabel(r\"$i$\")\n\n        cax = plt.cm.ScalarMappable(cmap=cm.gist_rainbow)\n        cax.set_array(Z)\n        cbar = plot3d_params[\"fig\"].colorbar(cax, ax=ax)\n        cbar.set_label(r\"$J$\")\n        return ax\n\n    pass\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/spinlattice/#oqd_trical.mechanical.spinlattice.SpinLattice.plot_interaction_graph","title":"<code>plot_interaction_graph(**kwargs)</code>","text":"<p>Plots the normal mode frequencies of the ions</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Figure for plot.</p> required <code>idx</code> <code>int</code> <p>3 digit integer representing position of the subplot.</p> required <code>plot_type</code> <code>str</code> <p>Type of plot.</p> required <p>Returns:</p> Name Type Description <code>ax</code> <code>Union[Axes3DSubplot, AxesSubplot]</code> <p>Axes of the plot</p> Source code in <code>src\\oqd_trical\\mechanical\\spinlattice.py</code> <pre><code>def plot_interaction_graph(self, **kwargs):\n    \"\"\"Plots the normal mode frequencies of the ions\n\n    Args:\n        fig (matplotlib.figure.Figure): Figure for plot.\n        idx (int): 3 digit integer representing position of the subplot.\n        plot_type (str): Type of plot.\n\n    Returns:\n        ax (Union[matplotlib.axes._subplots.Axes3DSubplot, matplotlib.axes._subplots.AxesSubplot]): Axes of the plot\n    \"\"\"\n    plot3d_params = {\n        \"fig\": plt.figure() if \"fig\" not in kwargs.keys() else None,\n        \"idx\": 111,\n        \"plot_type\": \"bar3d\",\n    }\n    plot3d_params.update(kwargs)\n\n    N = self.N\n    Z = self.J\n\n    if plot3d_params[\"plot_type\"] == \"bar3d\":\n        ax = plot3d_params[\"fig\"].add_subplot(plot3d_params[\"idx\"], projection=\"3d\")\n\n        Z = np.transpose(Z)\n\n        X, Y = np.meshgrid(np.linspace(0, N - 1, N), np.linspace(0, N - 1, N))\n\n        X = X.flatten()\n        Y = Y.flatten()\n        Z = Z.flatten()\n\n        W = Z - Z.min()\n        frac = W / W.max()\n        norm = colors.Normalize(frac.min(), frac.max())\n        color = cm.gist_rainbow(norm(frac))\n\n        ax.bar3d(X, Y, np.zeros(len(Z)), 1, 1, Z, color=color)\n        ax.set_xlabel(r\"$i$\")\n        ax.set_ylabel(r\"$j$\")\n        ax.set_zlabel(r\"$J$\")\n        ax.set_xticks(np.linspace(0.5, N - 0.5, N))\n        ax.set_xticklabels(range(N))\n        ax.set_yticks(np.linspace(0.5, N - 0.5, N))\n        ax.set_yticklabels(range(N))\n        ax.set_xlim(0, N)\n        ax.set_ylim(0, N)\n        ax.set_zlim(min(0, 1.1 * Z.min()), 1.1 * Z.max())\n    elif plot3d_params[\"plot_type\"] == \"imshow\":\n        ax = plot3d_params[\"fig\"].add_subplot(plot3d_params[\"idx\"])\n        ax.imshow(Z, cmap=cm.gist_rainbow)\n        ax.set_xlabel(r\"$j$\")\n        ax.set_ylabel(r\"$i$\")\n\n    cax = plt.cm.ScalarMappable(cmap=cm.gist_rainbow)\n    cax.set_array(Z)\n    cbar = plot3d_params[\"fig\"].colorbar(cax, ax=ax)\n    cbar.set_label(r\"$J$\")\n    return ax\n</code></pre>"},{"location":"reference/mechanical/spinlattice/#oqd_trical.mechanical.spinlattice.SimulatedSpinLattice","title":"<code>SimulatedSpinLattice</code>","text":"<p>               Bases: <code>SpinLattice</code></p> <p>Object representing a spin lattice system simulated by a trapped ion system.</p> <p>Parameters:</p> Name Type Description Default <code>ti</code> <code>TrappedIons</code> <p>A trapped ion system.</p> required <code>mu</code> <code>ndarray[float]</code> <p>Raman beatnote detunings.</p> required <code>Omega</code> <code>ndarray[float]</code> <p>Rabi frequencies.</p> required <p>Other Parameters:</p> Name Type Description <code>direc</code> <code>str</code> <p>Direction of mode to use.</p> <code>k</code> <code>float</code> <p>Wavevector of the laser.</p> Source code in <code>src\\oqd_trical\\mechanical\\spinlattice.py</code> <pre><code>class SimulatedSpinLattice(SpinLattice):\n    \"\"\"\n    Object representing a spin lattice system simulated by a trapped ion system.\n\n    Args:\n        ti (TrappedIons): A trapped ion system.\n        mu (np.ndarray[float]): Raman beatnote detunings.\n        Omega (np.ndarray[float]): Rabi frequencies.\n\n    Keyword Args:\n        direc (str): Direction of mode to use.\n        k (float): Wavevector of the laser.\n    \"\"\"\n\n    def __init__(self, ti, mu, Omega, **kwargs):\n        self.ti = ti\n        self.mu = np.array(mu)\n        self.Omega = np.array(Omega)\n\n        self.m = ti.m\n        self.N = ti.N\n\n        params = {\"direc\": \"x\", \"k\": np.pi * 2 / 355e-9}\n        params.update(kwargs)\n        self.__dict__.update(params)\n        self.params = params\n\n        if (\n            np.isin(\n                np.array([\"x_pa\", \"w_pa\", \"b_pa\"]), np.array(self.__dict__.keys())\n            ).sum()\n            != 3\n        ):\n            self.ti.principal_axes()\n\n        a = {\"x\": 0, \"y\": 1, \"z\": 2}[self.direc]\n        self.w = self.ti.w_pa[a * self.N : (a + 1) * self.N]\n        self.b = self.ti.b_pa[\n            a * self.N : (a + 1) * self.N, a * self.N : (a + 1) * self.N\n        ]\n\n        super(SimulatedSpinLattice, self).__init__(self.interaction_graph())\n        pass\n\n    def interaction_graph(self):\n        \"\"\"\n        Calculates the interaction graph of the spin lattice simulated by the trapped ion system.\n\n        Returns:\n            J (np.ndarray[float]): Interaction graph of the spin lattice simulated by the trapped ion system.\n        \"\"\"\n        try:\n            len(self.m)\n            eta = np.einsum(\n                \"in,in-&gt;in\",\n                self.b,\n                2 * self.k * np.sqrt(cst.hbar / (2 * np.outer(self.m, self.w))),\n            )\n        except Exception:\n            eta = np.einsum(\n                \"in,n-&gt;in\",\n                self.b,\n                2 * self.k * np.sqrt(cst.hbar / (2 * self.m * self.w)),\n            )\n\n        self.eta = eta\n        zeta = np.einsum(\"im,in-&gt;imn\", self.Omega, eta)\n        self.zeta = zeta\n        J = np.einsum(\n            \"ij,imn,jmn,n,mn-&gt;ij\",\n            1 - np.identity(self.N),\n            zeta,\n            zeta,\n            self.w,\n            1 / np.subtract.outer(self.mu**2, self.w**2),\n        )\n        return J\n\n    def plot_raman_beatnote_detunings(self, **kwargs):\n        pass\n\n    def plot_rabi_frequencies(self, **kwargs):\n        pass\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/spinlattice/#oqd_trical.mechanical.spinlattice.SimulatedSpinLattice.interaction_graph","title":"<code>interaction_graph()</code>","text":"<p>Calculates the interaction graph of the spin lattice simulated by the trapped ion system.</p> <p>Returns:</p> Name Type Description <code>J</code> <code>ndarray[float]</code> <p>Interaction graph of the spin lattice simulated by the trapped ion system.</p> Source code in <code>src\\oqd_trical\\mechanical\\spinlattice.py</code> <pre><code>def interaction_graph(self):\n    \"\"\"\n    Calculates the interaction graph of the spin lattice simulated by the trapped ion system.\n\n    Returns:\n        J (np.ndarray[float]): Interaction graph of the spin lattice simulated by the trapped ion system.\n    \"\"\"\n    try:\n        len(self.m)\n        eta = np.einsum(\n            \"in,in-&gt;in\",\n            self.b,\n            2 * self.k * np.sqrt(cst.hbar / (2 * np.outer(self.m, self.w))),\n        )\n    except Exception:\n        eta = np.einsum(\n            \"in,n-&gt;in\",\n            self.b,\n            2 * self.k * np.sqrt(cst.hbar / (2 * self.m * self.w)),\n        )\n\n    self.eta = eta\n    zeta = np.einsum(\"im,in-&gt;imn\", self.Omega, eta)\n    self.zeta = zeta\n    J = np.einsum(\n        \"ij,imn,jmn,n,mn-&gt;ij\",\n        1 - np.identity(self.N),\n        zeta,\n        zeta,\n        self.w,\n        1 / np.subtract.outer(self.mu**2, self.w**2),\n    )\n    return J\n</code></pre>"},{"location":"reference/mechanical/trappedions/","title":"Trapped Ions","text":""},{"location":"reference/mechanical/trappedions/#oqd_trical.mechanical.trappedions","title":"<code>oqd_trical.mechanical.trappedions</code>","text":""},{"location":"reference/mechanical/trappedions/#oqd_trical.mechanical.trappedions.TrappedIons","title":"<code>TrappedIons</code>","text":"<p>               Bases: <code>Base</code></p> <p>Object representing a system of trapped ions.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of ions.</p> required <code>ps</code> <code>Potential</code> <p>Potentials on the system.</p> <code>()</code> <p>Other Parameters:</p> Name Type Description <code>dim</code> <code>int</code> <p>Dimension of system.</p> <code>l</code> <code>float</code> <p>Length scale of system.</p> <code>m</code> <code>float</code> <p>Mass of ions</p> <code>q</code> <code>float</code> <p>Charge of ions</p> Source code in <code>src\\oqd_trical\\mechanical\\trappedions.py</code> <pre><code>class TrappedIons(Base):\n    \"\"\"\n    Object representing a system of trapped ions.\n\n    Args:\n        N (int): Number of ions.\n        ps (Potential): Potentials on the system.\n\n    Keyword Args:\n        dim (int): Dimension of system.\n        l (float): Length scale of system.\n        m (float): Mass of ions\n        q (float): Charge of ions\n\n    \"\"\"\n\n    def __init__(self, N, *ps, **kwargs):\n        super(TrappedIons, self).__init__()\n\n        params = {\n            \"dim\": ps[0].dim if \"dim\" in ps[0].__dict__.keys() else 3,\n            \"l\": 1e-6,\n            \"m\": 171 * cst.m_u,\n            \"q\": cst.e,\n        }\n        params.update(kwargs)\n        self.__dict__.update(params)\n\n        self.N = N\n        self.cp = CoulombPotential(N, dim=self.dim, q=self.q)\n\n        for p in ps:\n            p.update_params(N=N)\n        self.ps = np.array(ps)\n\n        self.fp = self.cp + self.ps.sum()\n        pass\n\n    def equilibrium_position(self, opt=dflt_opt, **kwargs):\n        \"\"\"\n        Function that calculates the equilibrium position of the ions.\n\n        Args:\n            opt (Callable): Generator of the appropriate optimization function for finding the equilibrium position.\n\n        Returns:\n            x_ep (np.ndarray[float]): Equilibrium position of the ions.\n        \"\"\"\n        ndcp = self.cp.nondimensionalize(self.l)\n        ndps = np.array([p.nondimensionalize(self.l) for p in self.ps])\n        ndfp = ndcp + ndps.sum()\n\n        def _ndfp(x):\n            return ndfp(x.reshape(self.dim, self.N).transpose())\n\n        self.x_ep = (\n            opt(self, **kwargs)(_ndfp).reshape(self.dim, self.N).transpose() * self.l\n        )\n        return self.x_ep\n\n    def normal_modes(self, block_sort=False):\n        \"\"\"\n        Function that calculates the normal modes of the system.\n\n        Args:\n            block_sort (bool): Indicator to apply block sorting.\n\n        Returns:\n            w (np.ndarray[float]): Normal mode frequencies of the system.\n            b (np.ndarray[float]): Normal mode eigenvectors of the system.\n        \"\"\"\n        ndcp = self.cp.nondimensionalize(self.l)\n        ndps = np.array([p.nondimensionalize(self.l) for p in self.ps])\n\n        def hess_phi(x):\n            return np.array([ndp.hessian()(x) for ndp in np.append(ndps, ndcp)]).sum(0)\n\n        if \"x_ep\" not in self.__dict__.keys():\n            self.equilibrium_position()\n\n        hess_phi_x_ep = hess_phi(self.x_ep / self.l)\n\n        if isinstance(self.m, float):\n            A = hess_phi_x_ep / self.m\n            w, b = np.linalg.eigh(A)\n        else:\n            A = np.einsum(\n                \"ij,i,j-&gt;ij\",\n                hess_phi_x_ep,\n                1 / np.tile(np.sqrt(self.m), 3),\n                1 / np.tile(np.sqrt(self.m), 3),\n            )\n            w, b = np.linalg.eigh(A)\n            b = np.einsum(\"im,i-&gt;im\", b, 1 / np.tile(np.sqrt(self.m), 3))\n            b = b / np.linalg.norm(b, axis=0)\n\n        w = np.sqrt(w * cst.k_e * cst.e**2 / self.l**3)\n\n        _b = np.round(np.copy(b), 3).transpose()\n        s = (np.sign(_b).sum(1) &gt;= 0) * 2 - 1\n        b = np.einsum(\"n,in-&gt;in\", s, b)\n\n        if block_sort:\n            n = np.round(\n                np.array(\n                    [\n                        np.linalg.norm(\n                            b[i * self.N : (i + 1) * self.N].transpose(), axis=-1\n                        )\n                        for i in range(self.dim)\n                    ]\n                )\n            ).astype(int)\n            idcs = np.lexsort(np.concatenate(((-w).reshape(1, -1), n)))\n        else:\n            idcs = np.argsort(np.flip(w, axis=0))\n\n        self.w, self.b, self.A = (\n            w[idcs],\n            b[:, idcs],\n            A * cst.k_e * cst.e**2 / self.l**3,\n        )\n        return self.w, self.b\n\n    def principal_axes(self, tol=1e-3):\n        \"\"\"\n        Function that calculates the principle axes of the system.\n\n        Args:\n            tol (float): Tolerance for evaluating orthogonality of principal axes.\n\n        Returns:\n            x_pa (np.ndarray[float]): Principle axes of the system.\n            w_pa (np.ndarray[float]): Normal mode frequencies of the system.\n            b_pa (np.ndarray[float]): Normal mode eigenvectors of the system in the principal axes coordinate system.\n        \"\"\"\n        if np.isin(np.array([\"w\", \"b\"]), np.array(self.__dict__.keys())).sum() != 2:\n            self.normal_modes()\n\n        xs = self.b.reshape(self.dim, -1).transpose()\n        x_pa = orthonormal_subset(xs, tol=tol)\n\n        assert len(x_pa) == self.dim, \"Principle axes do not exist\"\n\n        _x_pa = np.round(np.copy(x_pa), 3)\n        s = (np.sign(_x_pa).sum(1) &gt;= 0) * 2 - 1\n        x_pa = np.einsum(\"n,ni-&gt;ni\", s, x_pa)\n\n        _x_pa = np.round(np.copy(x_pa), 3)\n        idcs = np.lexsort(\n            np.concatenate((_x_pa.transpose(), np.abs(_x_pa).transpose()))\n        )\n\n        x_pa = x_pa[idcs]\n\n        b_pa = np.einsum(\"ij,jn-&gt;in\", x_pa, self.b.reshape(self.dim, -1)).reshape(\n            self.dim * self.N, -1\n        )\n        w_pa = self.w\n\n        _b = np.round(np.copy(b_pa), 3).transpose()\n        s = (np.sign(_b).sum(1) &gt;= 0) * 2 - 1\n        b_pa = np.einsum(\"n,in-&gt;in\", s, b_pa)\n\n        n = np.round(\n            np.array(\n                [\n                    np.linalg.norm(\n                        b_pa[i * self.N : (i + 1) * self.N].transpose(), axis=-1\n                    )\n                    for i in range(self.dim)\n                ]\n            )\n        ).astype(int)\n        idcs = np.lexsort(np.concatenate(((-w_pa).reshape(1, -1), n)))\n\n        self.x_pa, self.w_pa, self.b_pa = x_pa, w_pa[idcs], b_pa[:, idcs]\n        return self.x_pa, self.w_pa, self.b_pa\n\n    def update_params(self, **kwargs):\n        \"\"\"\n        Updates parameters, i.e. params attribute, of a TrappedIons object.\n\n        Args:\n            dim (float): Dimension of the system.\n            l (float): Length scale of the system.\n            m (float): Mass of an ion.\n            q (float: Charge of an ion.\n        \"\"\"\n        self.params.update(kwargs)\n        self.__dict__.update(self.params)\n        pass\n\n    def mode_ion_coupling(self):\n        if (\n            np.isin(\n                np.array([\"w_pa\", \"b_pa\", \"x_pa\"]), np.array(self.__dict__.keys())\n            ).sum()\n            != 3\n        ):\n            self.principal_axes()\n\n        mic = np.zeros((3 * self.N, 3 * self.N, 3 * self.N))\n        idcs = np.triu_indices(3 * self.N, k=1)\n        mic[:, idcs[0], idcs[1]] = mic[:, idcs[1], idcs[0]] = (\n            self.b_pa[np.array(idcs), :].prod(axis=0).transpose()\n        )\n        self.mic = mic\n        return self.mic\n\n    pass\n</code></pre>"},{"location":"reference/mechanical/trappedions/#oqd_trical.mechanical.trappedions.TrappedIons.equilibrium_position","title":"<code>equilibrium_position(opt=dflt_opt, **kwargs)</code>","text":"<p>Function that calculates the equilibrium position of the ions.</p> <p>Parameters:</p> Name Type Description Default <code>opt</code> <code>Callable</code> <p>Generator of the appropriate optimization function for finding the equilibrium position.</p> <code>dflt_opt</code> <p>Returns:</p> Name Type Description <code>x_ep</code> <code>ndarray[float]</code> <p>Equilibrium position of the ions.</p> Source code in <code>src\\oqd_trical\\mechanical\\trappedions.py</code> <pre><code>def equilibrium_position(self, opt=dflt_opt, **kwargs):\n    \"\"\"\n    Function that calculates the equilibrium position of the ions.\n\n    Args:\n        opt (Callable): Generator of the appropriate optimization function for finding the equilibrium position.\n\n    Returns:\n        x_ep (np.ndarray[float]): Equilibrium position of the ions.\n    \"\"\"\n    ndcp = self.cp.nondimensionalize(self.l)\n    ndps = np.array([p.nondimensionalize(self.l) for p in self.ps])\n    ndfp = ndcp + ndps.sum()\n\n    def _ndfp(x):\n        return ndfp(x.reshape(self.dim, self.N).transpose())\n\n    self.x_ep = (\n        opt(self, **kwargs)(_ndfp).reshape(self.dim, self.N).transpose() * self.l\n    )\n    return self.x_ep\n</code></pre>"},{"location":"reference/mechanical/trappedions/#oqd_trical.mechanical.trappedions.TrappedIons.normal_modes","title":"<code>normal_modes(block_sort=False)</code>","text":"<p>Function that calculates the normal modes of the system.</p> <p>Parameters:</p> Name Type Description Default <code>block_sort</code> <code>bool</code> <p>Indicator to apply block sorting.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>w</code> <code>ndarray[float]</code> <p>Normal mode frequencies of the system.</p> <code>b</code> <code>ndarray[float]</code> <p>Normal mode eigenvectors of the system.</p> Source code in <code>src\\oqd_trical\\mechanical\\trappedions.py</code> <pre><code>def normal_modes(self, block_sort=False):\n    \"\"\"\n    Function that calculates the normal modes of the system.\n\n    Args:\n        block_sort (bool): Indicator to apply block sorting.\n\n    Returns:\n        w (np.ndarray[float]): Normal mode frequencies of the system.\n        b (np.ndarray[float]): Normal mode eigenvectors of the system.\n    \"\"\"\n    ndcp = self.cp.nondimensionalize(self.l)\n    ndps = np.array([p.nondimensionalize(self.l) for p in self.ps])\n\n    def hess_phi(x):\n        return np.array([ndp.hessian()(x) for ndp in np.append(ndps, ndcp)]).sum(0)\n\n    if \"x_ep\" not in self.__dict__.keys():\n        self.equilibrium_position()\n\n    hess_phi_x_ep = hess_phi(self.x_ep / self.l)\n\n    if isinstance(self.m, float):\n        A = hess_phi_x_ep / self.m\n        w, b = np.linalg.eigh(A)\n    else:\n        A = np.einsum(\n            \"ij,i,j-&gt;ij\",\n            hess_phi_x_ep,\n            1 / np.tile(np.sqrt(self.m), 3),\n            1 / np.tile(np.sqrt(self.m), 3),\n        )\n        w, b = np.linalg.eigh(A)\n        b = np.einsum(\"im,i-&gt;im\", b, 1 / np.tile(np.sqrt(self.m), 3))\n        b = b / np.linalg.norm(b, axis=0)\n\n    w = np.sqrt(w * cst.k_e * cst.e**2 / self.l**3)\n\n    _b = np.round(np.copy(b), 3).transpose()\n    s = (np.sign(_b).sum(1) &gt;= 0) * 2 - 1\n    b = np.einsum(\"n,in-&gt;in\", s, b)\n\n    if block_sort:\n        n = np.round(\n            np.array(\n                [\n                    np.linalg.norm(\n                        b[i * self.N : (i + 1) * self.N].transpose(), axis=-1\n                    )\n                    for i in range(self.dim)\n                ]\n            )\n        ).astype(int)\n        idcs = np.lexsort(np.concatenate(((-w).reshape(1, -1), n)))\n    else:\n        idcs = np.argsort(np.flip(w, axis=0))\n\n    self.w, self.b, self.A = (\n        w[idcs],\n        b[:, idcs],\n        A * cst.k_e * cst.e**2 / self.l**3,\n    )\n    return self.w, self.b\n</code></pre>"},{"location":"reference/mechanical/trappedions/#oqd_trical.mechanical.trappedions.TrappedIons.principal_axes","title":"<code>principal_axes(tol=0.001)</code>","text":"<p>Function that calculates the principle axes of the system.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance for evaluating orthogonality of principal axes.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>x_pa</code> <code>ndarray[float]</code> <p>Principle axes of the system.</p> <code>w_pa</code> <code>ndarray[float]</code> <p>Normal mode frequencies of the system.</p> <code>b_pa</code> <code>ndarray[float]</code> <p>Normal mode eigenvectors of the system in the principal axes coordinate system.</p> Source code in <code>src\\oqd_trical\\mechanical\\trappedions.py</code> <pre><code>def principal_axes(self, tol=1e-3):\n    \"\"\"\n    Function that calculates the principle axes of the system.\n\n    Args:\n        tol (float): Tolerance for evaluating orthogonality of principal axes.\n\n    Returns:\n        x_pa (np.ndarray[float]): Principle axes of the system.\n        w_pa (np.ndarray[float]): Normal mode frequencies of the system.\n        b_pa (np.ndarray[float]): Normal mode eigenvectors of the system in the principal axes coordinate system.\n    \"\"\"\n    if np.isin(np.array([\"w\", \"b\"]), np.array(self.__dict__.keys())).sum() != 2:\n        self.normal_modes()\n\n    xs = self.b.reshape(self.dim, -1).transpose()\n    x_pa = orthonormal_subset(xs, tol=tol)\n\n    assert len(x_pa) == self.dim, \"Principle axes do not exist\"\n\n    _x_pa = np.round(np.copy(x_pa), 3)\n    s = (np.sign(_x_pa).sum(1) &gt;= 0) * 2 - 1\n    x_pa = np.einsum(\"n,ni-&gt;ni\", s, x_pa)\n\n    _x_pa = np.round(np.copy(x_pa), 3)\n    idcs = np.lexsort(\n        np.concatenate((_x_pa.transpose(), np.abs(_x_pa).transpose()))\n    )\n\n    x_pa = x_pa[idcs]\n\n    b_pa = np.einsum(\"ij,jn-&gt;in\", x_pa, self.b.reshape(self.dim, -1)).reshape(\n        self.dim * self.N, -1\n    )\n    w_pa = self.w\n\n    _b = np.round(np.copy(b_pa), 3).transpose()\n    s = (np.sign(_b).sum(1) &gt;= 0) * 2 - 1\n    b_pa = np.einsum(\"n,in-&gt;in\", s, b_pa)\n\n    n = np.round(\n        np.array(\n            [\n                np.linalg.norm(\n                    b_pa[i * self.N : (i + 1) * self.N].transpose(), axis=-1\n                )\n                for i in range(self.dim)\n            ]\n        )\n    ).astype(int)\n    idcs = np.lexsort(np.concatenate(((-w_pa).reshape(1, -1), n)))\n\n    self.x_pa, self.w_pa, self.b_pa = x_pa, w_pa[idcs], b_pa[:, idcs]\n    return self.x_pa, self.w_pa, self.b_pa\n</code></pre>"},{"location":"reference/mechanical/trappedions/#oqd_trical.mechanical.trappedions.TrappedIons.update_params","title":"<code>update_params(**kwargs)</code>","text":"<p>Updates parameters, i.e. params attribute, of a TrappedIons object.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>float</code> <p>Dimension of the system.</p> required <code>l</code> <code>float</code> <p>Length scale of the system.</p> required <code>m</code> <code>float</code> <p>Mass of an ion.</p> required <code>q</code> <code>float</code> <p>Charge of an ion.</p> required Source code in <code>src\\oqd_trical\\mechanical\\trappedions.py</code> <pre><code>def update_params(self, **kwargs):\n    \"\"\"\n    Updates parameters, i.e. params attribute, of a TrappedIons object.\n\n    Args:\n        dim (float): Dimension of the system.\n        l (float): Length scale of the system.\n        m (float): Mass of an ion.\n        q (float: Charge of an ion.\n    \"\"\"\n    self.params.update(kwargs)\n    self.__dict__.update(self.params)\n    pass\n</code></pre>"}]}